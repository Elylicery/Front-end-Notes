前端算法与数据结构

# 第1章 数据结构与算法

## 1-1 课程介绍 

<img src="前端算法与数据结构.assets/image-20201221205607585.png" alt="image-20201221205607585" style="zoom:80%;" />

<img src="前端算法与数据结构.assets/image-20201221205721606.png" alt="image-20201221205721606" style="zoom:80%;" />

<img src="前端算法与数据结构.assets/image-20201221205907582.png" alt="image-20201221205907582" style="zoom:80%;" />

<img src="前端算法与数据结构.assets/image-20201221205947124.png" alt="image-20201221205947124" style="zoom:80%;" />



## 1-2 数据结构与算法简介 

*要学习的数据结构*

* 栈、队列、链表
* 集合、字典
* 树、堆、图

*将要学习的算法*

* 链表：遍历链表、删除链表节点
* 树、图：深度/广度优先遍历
* 数组：冒泡/选择/插入/归并/快速排序、顺序/二分搜索

##  1-3 如何刷 LeetCode？ 

* 集中于一类刷题

  ![image-20201221210816215](前端算法与数据结构.assets/image-20201221210816215.png)

* 善用功能：使用leetcode的笔记（常复习）

# 第2章 时间/空间复杂度

只会做题可不行，还得会分析时间复杂度和空间复杂度，快来做个追求极致的程序员吧！

##  2-1 时间复杂度

<img src="前端算法与数据结构.assets/image-20201221211227446.png" alt="image-20201221211227446" style="zoom:80%;" />

<img src="前端算法与数据结构.assets/image-20201221211237676.png" alt="image-20201221211237676" style="zoom:80%;" />

##   2-2 空间复杂度

<img src="前端算法与数据结构.assets/image-20201221211344901.png" alt="image-20201221211344901" style="zoom:80%;" />

# 第3章 栈

前置技巧：

打断点后按F5可以进行断点调试

![image-20201221213329048](前端算法与数据结构.assets/image-20201221213329048.png)

##  3-1 栈简介

**栈是什么？**

* 一个*后进先出*的数据结构
* JS中没有栈，但可以用Array实现栈的所有功能
* 栈常用操作：`push` `pop` `stack[stack.length-1]`

```js
const stack = [];

//入栈
stack.push(1);
stack.push(2);

//出栈
const item1 = stack.pop();
```

##   3-2 什么场景下用栈

<img src="前端算法与数据结构.assets/image-20201221213610378.png" alt="image-20201221213610378" style="zoom: 80%;" />

<img src="前端算法与数据结构.assets/image-20201221213719434.png" alt="image-20201221213719434" style="zoom: 80%;" />

<img src="前端算法与数据结构.assets/image-20201221213811571.png" alt="image-20201221213811571" style="zoom: 80%;" />

<img src="前端算法与数据结构.assets/image-20201221214016030.png" alt="image-20201221214016030" style="zoom:80%;" />



##   3-3 LeetCode：20.有效的括号 

<img src="前端算法与数据结构.assets/image-20201221214347367.png" alt="image-20201221214347367" style="zoom:80%;" />

<img src="前端算法与数据结构.assets/image-20201221214420918.png" alt="image-20201221214420918" style="zoom:80%;" />

<img src="前端算法与数据结构.assets/image-20201221214557186.png" alt="image-20201221214557186" style="zoom:80%;" />



```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function (s) {
    if(s.length%2===1){
        return false;
    }
    const stack = [];
    for (let i = 0; i < s.length; i++) {
        const c = s[i];
        if (c === '(' || c === '[' || c === '{') {
            stack.push(c);
        } else {
            const t = stack[stack.length - 1];
            if (
                (t === '(' && c === ')') ||
                (t === '[' && c === ']') ||
                (t === '{' && c === '}')
            ) {
                stack.pop();
            } else {
                return false;
            }
        }
    }
    return stack.length === 0;
};
```



##  3-4 前端与栈：JS 中的函数调用堆栈 

![image-20201221220413842](前端算法与数据结构.assets/image-20201221220413842.png)

> CallStack：JS解释器是用栈这种数据结构控制函数调用的

##  3-5 LeetCode：144. 二叉树的前序遍历

![image-20201221220656417](前端算法与数据结构.assets/image-20201221220656417.png)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    const res = [];
    const stack = [];
    if(root) stack.push(root);
    while(stack.length){
        const n = stack.pop();
        res.push(n.val);
        if(n.right) stack.push(n.right);
        if(n.left) stack.push(n.left);
    }
    return res;
};
```

## 3.6 思考2 使用class封装一个Stack类

```js
class Stack{
  constructor(){
    this.items = [];
  }

  //入栈(数组尾部添加元素)
  push(element){
    this.items.push(element);
  }
  //出栈(数组尾部的元素)
  pop(){
    return this.items.pop();
  }
  //查看栈顶元素
  peek(){
    return this.items[this.items.length-1];
  }
  //检查栈是否为空
  isEmpty(){
    return !this.items.length;
  }
  //清空栈
  clear(){
    this.items = [];
  }
  //查看栈中元素的数量
  size(){
    return this.items.length;
  }
}
```

验证：

```js
// 我们先来创建一个栈验证一下是否为空
const stack = new Stack(); // 新建一个栈
console.log(stack.isEmpty()); // true

// 继续向栈中添加2个元素
stack.push('hello');
stack.push('world');

// 此时我们调用peek方法查看栈顶的元素
console.log(stack.peek()); // 'world'

// 调用size方法查看一下元素的数量
console.log(stack.size()) // 2

// 继续向栈中添加元素
stack.push('.');
stack.push('JavaScript');

// 移出一个元素
console.log(stack.pop()); // 'JavaScript'

// 清空栈
stack.clear();
console.log(stack.size()); // 0
console.log(stack.isEmpty()); // true
```

##   3-7 思考2 十进制转二进制

```js
var DectoBin = function(num){
  const stack = [];
  while(num){
    const n = num%2;
    stack.push(n);
    num = Math.floor(num/2)
  }
  var res = '';
  while(stack.length){
    res += stack.pop();
  }
  return res;
}

console.log(DectoBin(35));
```

# 第4章 队列

## 4-1 队列简介 

<img src="前端算法与数据结构.assets/image-20201225101321511.png" alt="image-20201225101321511" style="zoom:67%;" />

![image-20201225103248334](前端算法与数据结构.assets/image-20201225103248334.png)

```js
const queue = [];
//入队
queue.push(1);
queue.push(2);
//出队
const item1 = queue.shift();
```

## 4-2 什么场景用队列 

<img src="前端算法与数据结构.assets/image-20201225101556485.png" alt="image-20201225101556485" style="zoom:67%;" />

![image-20201225101732458](前端算法与数据结构.assets/image-20201225101732458.png)

![image-20201225101916611](前端算法与数据结构.assets/image-20201225101916611.png)

## 4-3 LeetCode：933. 最近的请求次数

![image-20201225102809776](前端算法与数据结构.assets/image-20201225102809776.png)

<img src="前端算法与数据结构.assets/image-20201225102254215.png" alt="image-20201225102254215" style="zoom:80%;" />

<img src="前端算法与数据结构.assets/image-20201225102308389.png" alt="image-20201225102308389" style="zoom:80%;" />

```js
var RecentCounter = function() {
    this.q = [];
};

/** 
 * @param {number} t
 * @return {number}
 */
RecentCounter.prototype.ping = function(t) {
    this.q.push(t);
    while(this.q[0]< t-3000){
        this.q.shift();
    }
    return this.q.length;
};

/**
 * Your RecentCounter object will be instantiated and called as such:
 * var obj = new RecentCounter()
 * var param_1 = obj.ping(t)
 */
```

## 4-4 前端与队列：JS 异步中的任务队列 

![image-20201225102932241](前端算法与数据结构.assets/image-20201225102932241.png)

![image-20201225102941974](前端算法与数据结构.assets/image-20201225102941974.png)



## 4-5 思考1 用class封装一个Queue类

> 参考：https://wangtunan.github.io/blog/books/javascript/algorithm.html#%E9%98%9F%E5%88%97%E5%92%8C%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97

```js
class Queue{
  constructor(){
    this.count = 0;
    this.items = [];
  }
  size(){
    return this.count;
  }
  isEmpty(){
    return this.count === 0;
  }
  enqueue(element){
    this.items.push(element);
    this.count++;
  }
  dequeue(){
    if(this.isEmpty()){
      return undefined;
    }
    this.count = this.count-1;
    return this.items.shift();
  }
  peek(){
    return this.items[0];
  }
  clear(){
    this.count = 0;
    this.items = [];
  }
}

const queue = new Queue()
console.log(queue.isEmpty())  // true
queue.enqueue('AAA')
queue.enqueue('BBB')
queue.enqueue('CCC')
console.log(queue.isEmpty())  // false
console.log(queue.size())     // 3
console.log(queue) // AAA,BBB,CCC
console.log(queue.peek())     // AAA
queue.dequeue()
queue.clear()
console.log(queue.isEmpty())  // true
```

思考2  用队列结合React或Vue写一个任务APP

请用队列这个数据结构结合React或Vue写一个任务APP，包括添加任务和完成任务功能，要求任务只能先进先出



# 第5章 链表

与栈和队列不同，链表元素的存储不是连续的。链表是非常高频的考点，在前端的日常工作中也有举足轻重的地位，这章一定要好好学习呦！

## 5-1 链表简介

<img src="前端算法与数据结构.assets/image-20201225203231963.png" alt="image-20201225203231963" style="zoom:67%;" />

<img src="前端算法与数据结构.assets/image-20201225203259689.png" alt="image-20201225203259689" style="zoom:67%;" />

<img src="前端算法与数据结构.assets/image-20201225203309330.png" alt="image-20201225203309330" style="zoom:67%;" />

```js
const a = {val:'a'};
const b = {val:'b'};
const c = {val:'c'};
const d = {val:'d'};
a.next = b;
b.next = c;
c.next = d;

//遍历链表
let p = a;
while(p){
  console.log(p.val);
  p = p.next;
}

//插入e到c和d之间
const e = {val:'e'};
c.next = e;
e.next = d;

//删除
c.next = d;
```

**技术要点**

* 链表里的元素存储不是连续的，之间通过next连接
* JS中没有链表，但可以用Object模拟链表
* 链表常用操作：修改next、遍历链表
* JS中的原型链也是一个链表（沿着`__proto__`走）
* 使用链表指针可以获取JSON的节点值

## 5-2 LeetCode：237.删除链表中的节点 

<img src="前端算法与数据结构.assets/image-20201225204021221.png" alt="image-20201225204021221" style="zoom:80%;" />

<img src="前端算法与数据结构.assets/image-20201225204224605.png" alt="image-20201225204224605" style="zoom: 50%;" />

<img src="前端算法与数据结构.assets/image-20201225204249615.png" alt="image-20201225204249615" style="zoom:50%;" />

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} node
 * @return {void} Do not return anything, modify node in-place instead.
 */
var deleteNode = function(node) {
    node.val = node.next.val;
    node.next = node.next.next;
};
```



## 5-3 LeetCode：206.反转链表 

![image-20201225204433050](前端算法与数据结构.assets/image-20201225204433050.png)

![image-20201225204515450](前端算法与数据结构.assets/image-20201225204515450.png)

![image-20201225204616880](前端算法与数据结构.assets/image-20201225204616880.png)

我们可以申请两个指针，第一个指针叫 pre，最初是指向 null 的。
第二个指针 cur 指向 head，然后不断遍历 cur。
每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。
都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了。

很好的图解：https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/

```js
var reverseList = function(head) {
    let pre = null;
    let cur = head;
    while(cur){
        const tmp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = tmp;
    }
    return pre;
};
```

## 5-4 LeetCode：2. 两数相加 

https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-by-leetcode-solution/

<img src="前端算法与数据结构.assets/image-20201225211820848.png" alt="image-20201225211820848" style="zoom: 80%;" />

<img src="前端算法与数据结构.assets/image-20201225212242118.png" alt="image-20201225212242118" style="zoom: 80%;" />

<img src="前端算法与数据结构.assets/image-20201225212312542.png" alt="image-20201225212312542" style="zoom:80%;" />

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    const l3 = new ListNode(0);
    let p1 = l1;
    let p2 = l2;
    let p3 = l3;
    let carry = 0;
    while(p1 || p2){
        const v1 = p1 ? p1.val:0;
        const v2 = p2 ? p2.val:0;
        const val = v1 + v2 + carry;
        carry = Math.floor(val/10);
        p3.next = new ListNode(val % 10);
        if(p1) p1 = p1.next;
        if(p2) p2 = p2.next;
        p3 = p3.next;
    }
    if(carry){
        p3.next = new ListNode(carry);
    }
    return l3.next;
};
```

## 5-5 LeetCode：83. 删除排序链表中的重复元素

<img src="前端算法与数据结构.assets/image-20201225214834263.png" alt="image-20201225214834263" style="zoom:67%;" />

<img src="前端算法与数据结构.assets/image-20201225214910161.png" alt="image-20201225214910161" style="zoom: 33%;" />

<img src="前端算法与数据结构.assets/image-20201225214943066.png" alt="image-20201225214943066" style="zoom:33%;" />

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var deleteDuplicates = function(head) {
    let p = head;
    while(p && p.next){
        //相同继续判断（避免多个连续相同值的情况）
        if(p.val === p.next.val){
            p.next = p.next.next;
        }else{
            //不相同在后移指针
            p = p.next;
        }
    }
    return head;
};
```

## 5-6 LeetCode：141. 环形链表 

<img src="前端算法与数据结构.assets/image-20201225220149156.png" alt="image-20201225220149156" style="zoom:80%;" />

<img src="前端算法与数据结构.assets/image-20201225220327426.png" alt="image-20201225220327426" style="zoom: 33%;" />

<img src="前端算法与数据结构.assets/image-20201225220358192.png" alt="image-20201225220358192" style="zoom:33%;" />



```js
var hasCycle = function(head) {
    let p1 = head;
    let p2 = head;
    while(p1 && p2 && p2.next){
        p1 = p1.next;
        p2 = p2.next.next;
        if(p1 === p2){
            return true;
        }
    }
    return false;
};
```

## 5-7 前端与链表：JS 中的原型链 

<img src="前端算法与数据结构.assets/image-20201226204757896.png" alt="image-20201226204757896" style="zoom: 50%;" />

<img src="前端算法与数据结构.assets/image-20201226204955102.png" alt="image-20201226204955102" style="zoom:50%;" />

![image-20201226205653873](前端算法与数据结构.assets/image-20201226205653873.png)

<img src="前端算法与数据结构.assets/image-20201226205918915.png" alt="image-20201226205918915" style="zoom:50%;" />

1.  ` instanceof`举例

```js
const obj = {}
const func = ()=>{};
const arr = [];

obj instanceof Object //true
func instanceof Function //true
func instanceof Object //true
arr instanceof Array //true
arr instanceof Object //true
```

2.  沿着原型链查找对象

```js
const obj = {}
Object.prototype.x ='x';

console.log(obj.x) //x

const func = () =>{};
Function.prototype.y = 'y';
console.log(func.y)//y
```

<img src="前端算法与数据结构.assets/image-20201226210535935.png" alt="image-20201226210535935" style="zoom:50%;" />

<img src="前端算法与数据结构.assets/image-20201226210620582.png" alt="image-20201226210620582" style="zoom:50%;" />

```js
//判断A是否是B的实例
const instanceOf = (A,B) => {
    let p = A;
    while(p){
        if(p === B.prototype){
            return true;
        }
        p = p.__proto__;
    }
    return false;
};

//测试
instanceof([],Object)//true
instanceof(1,Number)//true
```

<img src="前端算法与数据结构.assets/image-20201226210906699.png" alt="image-20201226210906699" style="zoom: 67%;" />

<img src="前端算法与数据结构.assets/image-20201226210959913.png" alt="image-20201226210959913" style="zoom: 50%;" />

```js
var foo = {},
    F = function(){};

Object.prototype.a = "value a";
Function.prototype.b = "value b";

console.log(foo.a);//value a
console.log(foo.b)//undefined

console.log(F.a);//value a
console.log(F.b);//value b
```



## 5-8 前端与链表：使用链表指针获取 JSON 的节点值 

```js
const json = {
  a:{b:{c:1}},
  d:{e:2},
}

//沿着路径查找json的某一个节点值
const path = ['a','b','c'];

let p = json;
path.forEach(k =>{
  p = p[k]
});

console.log(p);//1
```



## 5-10 思考一 判断链表是否为回文链表

https://leetcode-cn.com/problems/palindrome-linked-list/



# 第6章 集合

## 6-1 集合简介 

<img src="前端算法与数据结构.assets/image-20201229100201092.png" alt="image-20201229100201092" style="zoom:50%;" />

```js
//去重
const arr = [1,1,2,3];
const arr2 = [...new Set(arr)];
console.log(arr2);//1,2,3

//判断元素是否在集合中
const set = new Set(arr);
const has = set.has(3);
console.log(has);//true

//求交集
const set2 = new Set([2,3]);
const set3 = new Set([...set].filter(item => set2.has(item)));
console.log([...set3]);//[2,3]
```



## 6-2 LeetCode：349. 两个数组的交集 

<img src="前端算法与数据结构.assets/image-20201229101620287.png" alt="image-20201229101620287" style="zoom:67%;" />

<img src="前端算法与数据结构.assets/image-20201229101713695.png" alt="image-20201229101713695" style="zoom:50%;" />

<img src="前端算法与数据结构.assets/image-20201229101734362.png" alt="image-20201229101734362" style="zoom:50%;" />

```js
var intersection = function(nums1, nums2) {
    return [...new Set(nums1)].filter(n => nums2.includes(n));
};
```

注意：判断一个数值是否在数组里 **includes方法**

## 6-3 前端与集合：使用 ES6 中 Set

![image-20201229102231206](前端算法与数据结构.assets/image-20201229102231206.png)

```js
let mySet = new Set();

//add
mySet.add(1);
mySet.add(5);
mySet.add(5);
mySet.add('some text');
let o = {a:1,b:2};
mySet.add(o);
mySet.add({a:1,b:2})//set里有5个元素，两个对象不同

//has
const has = mySet.has() //has为true
const has2 = mySet.has(o) //has2为true

//delete
mySet.delete(5);

//size
console.log(mySet.size);//4

//迭代set
for(let item of mySet) console.log(item);

for(let item of mySet.keys()) console.log(item);
for(let item of mySet.values()) console.log(item);
for(let [key,value] of mySet.entries()) console.log(key,"-",value);//对于set，其key和value一样

//set array互转
const myArr = [...mySet];
const myArr2 = Array.from(mySet);
const mySet2 = new Set([1,2,3,4]);

//交集差集
const intersection = new Set([...mySet].filter(x => mySet2.has(x)));
const difference = new Set([...mySet].filter(x => !mySet2.has(x)))
```



## 6-4 思考题一 数据库的inner jsoin

在学习数据库的使用时，都有使用过Join，对数据库中的两张或两张以上表进行连接操作。
**注释：**INNER JOIN 与 JOIN 是相同的。



# 第7章 字典

## 7-1 字典简介

<img src="前端算法与数据结构.assets/image-20201230201144229.png" alt="image-20201230201144229" style="zoom: 50%;" />

```js
const m = new Map();

//增
m.set('a','aa');
m.set('b','bb');
//删
m.delete('b');
//m.clear();

//改
m.set('a','aaa');

//查
console.log(m.get('a'));//aaa
console.log(m.has('a'));//true

```

## 7-2 LeetCode：349. 两个数组的交集 

<img src="前端算法与数据结构.assets/image-20201230201741259.png" alt="image-20201230201741259" style="zoom:50%;" />

<img src="前端算法与数据结构.assets/image-20201230201821738.png" alt="image-20201230201821738" style="zoom:50%;" />

<img src="前端算法与数据结构.assets/image-20201230201853555.png" alt="image-20201230201853555" style="zoom:50%;" />

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function(nums1, nums2) {
    const map = new Map();
    nums1.forEach(n => {
        map.set(n,true);
    });
    const res = [];
    nums2.forEach(n=>{
        if(map.get(n)){
            res.push(n);
            map.delete(n);
        }
    });
    return res;
};
```



## 7-3 LeetCode：20.有效的括号

![image-20201230203321091](前端算法与数据结构.assets/image-20201230203321091.png)

优化后的使用字典的版本

用时和内存消耗都有很大的提升
重构后的代码：
时间复杂度不变
空间增加一个O（1）的map，其空间复杂度仍是O（n）

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function (s) {
    if(s.length%2===1){
        return false;
    }
    const stack = [];
    //字典
    const map = new Map();
    map.set('(',')');
    map.set('[',']');
    map.set('{','}');

    for (let i = 0; i < s.length; i++) {
        const c = s[i];
        if (map.has(c)) {
            stack.push(c);
        } else {
            const t = stack[stack.length - 1];
            if (map.get(t) === c) {
                stack.pop();
            } else {
                return false;
            }
        }
    }
    return stack.length === 0;
};

```

## 7-4 LeetCode：1. 两数之和

<img src="前端算法与数据结构.assets/image-20201230203847996.png" alt="image-20201230203847996" style="zoom: 67%;" />

<img src="前端算法与数据结构.assets/image-20201230204030133.png" alt="image-20201230204030133" style="zoom: 50%;" />

<img src="前端算法与数据结构.assets/image-20201230204151161.png" alt="image-20201230204151161" style="zoom:50%;" />

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    const map = new Map();
    for(let i=0;i<nums.length;i++){
        const n = nums[i];
        const n2 = target - n;
        if(map.has(n2)){
            return [map.get(n2),i];
        }else{
            map.set(n,i);
        }
    }
};
```



## 7-5 LeetCode：3. 无重复字符的最长子串 

<img src="前端算法与数据结构.assets/image-20201230204540299.png" alt="image-20201230204540299" style="zoom: 67%;" />

注意：子串是连续的，元字符串的一段完整剪切

<img src="前端算法与数据结构.assets/image-20201230211156025.png" alt="image-20201230211156025" style="zoom:50%;" />

<img src="前端算法与数据结构.assets/image-20201230211408339.png" alt="image-20201230211408339" style="zoom:50%;" />

```js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    //左指针其实位置
    let l =0;
    let res = 0;
    //利用map字典查看子串是否包含重复子串
    const map = new Map();
    //滑动窗口（右指针不断右移）
    for(let r =0;r<s.length;r++){
        //当前字符如果是重复字符 并且重复元素在滑动窗口内 
        if(map.has(s[r]) && map.get(s[r])>=l){
            //左指针移动
            l = map.get(s[r])+1;
        }
        //窗口长度的较大值
        res = Math.max(res,r-l+1);
        //将当前字符的字符和下标放入字典
        map.set(s[r],r);
    }
    return res;
};

```



## 7-6 LeetCode：76. 最小覆盖子串 

<img src="前端算法与数据结构.assets/image-20201230213000747.png" alt="image-20201230213000747" style="zoom:80%;" />

<img src="前端算法与数据结构.assets/image-20201230213024603.png" alt="image-20201230213024603" style="zoom:50%;" />

<img src="前端算法与数据结构.assets/image-20201230213239023.png" alt="image-20201230213239023" style="zoom:50%;" />

题目比较复杂，下面整理一下思路：

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {string}
 */
var minWindow = function(s, t) {
    //初始化双指针，维护滑动窗口
    let l = 0;
    let r = 0;

    //字典： 滑动窗口需要的字符 和 它的个数
    const need = new Map();
    for(let c of t){
        need.set(c,need.has(c)?need.get(c)+1:1)
    }
    //eg 对于"ABC"的输入，need是 Map{'A'=>1,'B'=>1,'C'=>1}
    let needType = need.size;
    let res = '';
    //移动右指针
    while(r<s.length){
        //获取当前字符
        const c = s[r];
        //如果字符在需要的字符列表里
        if(need.has(c)){
            need.set(c,need.get(c)-1);
            if(need.get(c) === 0) needType -=1;
        }
        //如果找到包含t的子串，就移动左指针
        while(needType === 0){
            //找到包含t的子串其中最小的
            const newRes = s.substring(l,r+1);
            if(!res || newRes.length < res.length) res = newRes;
            const c2 = s[l];
            if(need.has(c2)){
                need.set(c2,need.get(c2)+1);
                if(need.get(c2) === 1) needType+=1;
            }
            l+=1;
        }
        r+=1;
    }
    return res;
};
```

时间复杂度：O(m+n) m是t的长度，n是s的长度
空间负责度：O(m)

## 7-7 思考一 比较map与object 性能

> MDN:https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map

[`Objects`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object) 和 `Maps` 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成 `Maps` 使用。不过 `Maps` 和 `Objects` 有一些重要的区别，在下列情况里使用 `Map` 会是更好的选择：

| Map      | Object                                                       |                                                              |
| :------- | :----------------------------------------------------------- | ------------------------------------------------------------ |
| 意外的键 | `Map` 默认情况不包含任何键。只包含显式插入的键。             | 一个 `Object` 有一个原型, 原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。**注意:** 虽然 ES5 开始可以用 `Object.create(null)` 来创建一个没有原型的对象，但是这种用法不太常见。 |
| 键的类型 | 一个 `Map`的键可以是**任意值**，包括函数、对象或任意基本类型。 | 一个`Object` 的键必须是一个 [`String`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String) 或是[`Symbol`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)。 |
| 键的顺序 | `Map` 中的 key 是有序的。因此，当迭代的时候，一个 `Map` 对象以插入的顺序返回键值。 | 一个 `Object` 的键是无序的注意：自ECMAScript 2015规范以来，对象*确实*保留了字符串和Symbol键的创建顺序； 因此，在只有字符串键的对象上进行迭代将按插入顺序产生键。 |
| Size     | `Map` 的键值对个数可以轻易地通过[`size`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/size) 属性获取 | `Object` 的键值对个数只能手动计算                            |
| 迭代     | `Map` 是 [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/iterable) 的，所以可以直接被迭代。 | 迭代一个`Object`需要以某种方式获取它的键然后才能迭代。       |
| ==性能== | **在频繁增删键值对的场景下表现更好。**                       | 在频繁添加和删除键值对的场景下未作出优化。                   |



# 第8章 树

## 8-1 树简介

![image-20210104155808268](前端算法与数据结构.assets/image-20210104155808268.png)

![image-20210104160033147](前端算法与数据结构.assets/image-20210104160033147.png) 

## 8-2 深度与广度优先遍历 

![image-20210104160134306](前端算法与数据结构.assets/image-20210104160134306.png)

```js
const tree = {
  val:'a',
  children:[
    {
      val:'b',
      children:[
        {
          val:'d',
          children:[]
        },
        {
          val:'e',
          children:[]
        },
      ]
    },
    {
      val:'c',
      children:[
        {
          val:'f',
          children:[]
        },
        {
          val:'g ',
          children:[]
        },
      ]
    }
  ]
};
```

**DFS**

![image-20210104160852604](前端算法与数据结构.assets/image-20210104160852604.png)

```js
const dfs = (root) =>{
  console.log(root.val);
  root.children.forEach((child)=>{dfs(child)})
  //root.children.forEach(dfs)
}

dfs(tree)
// a b d e c f g 
```

BFS

![image-20210104161510855](前端算法与数据结构.assets/image-20210104161510855.png)

```js
const bfs = (root) =>{
  const q = [root];
  while(q.length>0){
    const n = q.shift();
    console.log(n.val);
    n.children.forEach(child =>{
      q.push(child);
    })
  }
}

bfs(tree);
// a b c d e f g
```

## 8-3 二叉树的先中后序遍历 

![image-20210104163212832](前端算法与数据结构.assets/image-20210104163212832.png)

![image-20210104163253929](前端算法与数据结构.assets/image-20210104163253929.png)

测试输入：

![image-20210104164216207](前端算法与数据结构.assets/image-20210104164216207.png)

BinaryTree

```js
const bt = {
  val:1,
  left:{
    val:2,
    left:{
      val:4,
      left:null,
      right:null,
    },
    right:{
      val:5,
      left:null,
      right:null,
    },
  },
  right:{
    val:3,
    left:{
      val:6,
      left:null,
      right:null,
    },
    right:{
      val:7,
      left:null,
      right:null,
    },
  },
};

module.exports = bt;
```

```js
const bt = require('./bt');

const preorder = (root) => {
  if(!root){
    return;
  }
  console.log(root.val);
  preorder(root.left);
  preorder(root.right);
}

preorder(bt);
//1
2
4
5
3
6
7
```

![image-20210104164235488](前端算法与数据结构.assets/image-20210104164235488.png)

```js
const bt = require('./bt');

const inorder = (root) =>{
  if(!root) {return;}
  inorder(root.left);
  console.log((root.val));
  inorder(root.right);
}

inorder(bt);
// 4
// 2
// 5
// 1
// 6
// 3
// 7
```

![image-20210104164511494](前端算法与数据结构.assets/image-20210104164511494.png)

```js
const bt = require('./bt');

const postorder = (root) =>{
  if(!root) {return;}
  postorder(root.left);
  postorder(root.right);
  console.log(root.val);
}

postorder(bt)
// 4
// 5
// 2
// 6
// 7
// 3
// 1
```

## 8-4 二叉树的先中后序遍历（非递归版） 

递归版太简单了，一般不会考察。考察非递归版

使用堆栈模拟递归调用的过程

**前序遍历**

```js
const bt = require("./bt");

const preorder = (root) => {
	if (!root) {
		return;
	}
	const stack = [root];
	while (stack.length) {
		const n = stack.pop();
		console.log(n.val);
		if (n.right) stack.push(n.right);
		if (n.left) stack.push(n.left);
	}
};

preorder(bt);
```

备注：因为是先访问左子树载访问右子树，所以要先放入右子树，再放入左子树

**中序遍历**

```js
const bt = require("./bt");

const inorder = (root) => {
	if (!root) { return;}
  	const stack = [];
  	let p = root;
  	while(stack.length || p){
    	while(p){
      	stack.push(p);
      	p = p.left;
    	}
    	const n = stack.pop();
    	console.log(n.val);
    	p = n.right;
  	}
};

inorder(bt);
```

**后序遍历**

先序遍历是根-左-右，后序遍历是左-右-根

* 可以把先序先改为 根-右-左，然后进行倒序变为左-右-根
* 把访问改成入栈操作，逆序输出就可

```js
const bt = require("./bt");

const postorder = (root) =>{
  if(!root) {return;}
  const stack = [root];
  const outputStack = [];
  while(stack.length){
    const n = stack.pop();
    outputStack.push(n);
    if(n.left) stack.push(n.left);
    if(n.right) stack.push(n.right);
  }

  //倒序输出
  while(outputStack.length){
    const n = outputStack.pop();
    console.log(n.val);
  }
}

postorder(bt)
```



## 8-5 LeetCode：104. 二叉树的最大深度 

![image-20210104171842397](前端算法与数据结构.assets/image-20210104171842397.png)

![image-20210104171959283](前端算法与数据结构.assets/image-20210104171959283.png)

![image-20210104172026755](前端算法与数据结构.assets/image-20210104172026755.png)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    let res = 0;
    const dfs = (n,l) =>{
        if(!n) {return;}
        res = Math.max(res,l);
        //console.log(n.val,l);
        dfs(n.left,l+1);
        dfs(n.right,l+1);
    };
    dfs(root,1);
    return res;
};
```

速度为什么会慢？因为遍历这个树上每一个节点都刷新一次res，速度很慢

优化：当该节点是叶子节点的时候，才刷新res

```js
var maxDepth = function(root) {
    let res = 0;
    const dfs = (n,l) =>{
        if(!n) {return;}
        if(!n.left && !n.right){
            res = Math.max(res,l);
        }
        //console.log(n.val,l);
        dfs(n.left,l+1);
        dfs(n.right,l+1);
    };
    dfs(root,1);
    return res;
};
```

时间：O(n)

空间：函数调用堆栈，dfs一共嵌套的层数是二叉树的最大深度

* 最坏的情况：单叉树，O(n)
* 最好的情况：二叉树均匀分布，O(logn)

## 8-6 LeetCode：111. 二叉树的最小深度 

![image-20210104205427925](前端算法与数据结构.assets/image-20210104205427925.png)

![image-20210104205538011](前端算法与数据结构.assets/image-20210104205538011.png)

![image-20210104205555967](前端算法与数据结构.assets/image-20210104205555967.png)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    if(!root) {return 0;}
    const q = [[root,1]];
    while(q.length){
        const [n,l] = q.shift();
        if(!n.left && !n.right){
            return l;
        }
        console.log(n.val,1);
        if(n.left) q.push([n.left,l+1]);
        if(n.right) q.push([n.right,l+1]);
    }
};
```

时间：O(n)

空间:O(n)

n是节点的数量

## 8-7 LeetCode：102. 二叉树的层序遍历 

![image-20210104210351129](前端算法与数据结构.assets/image-20210104210351129.png)

![image-20210104210449022](前端算法与数据结构.assets/image-20210104210449022.png)

![image-20210104210552071](前端算法与数据结构.assets/image-20210104210552071.png)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    //广度优先遍历记录层级
    if(!root) return [];
    const q = [[root,0]];
    const res = [];
    while(q.length){
        const [n,level] = q.shift();
        //console.log(n.val,level);
        //放入相同层级的数组
        if(!res[level]){
            res.push([n.val])
        }else{
            res[level].push(n.val)
        }
        if(n.left) q.push([n.left,level+1]);
        if(n.right) q.push([n.right,level+1]);
    }
    return res;
};
```

另一种方法：

每次都是将某一层级的所有节点出队，然后将其所有孩子入队。

```js
var levelOrder = function(root) {
    if(!root) return [];
    const q = [root];
    const res =[];
    while(q.length){
        let len = q.length;
        res.push([]);
        while(len--){
            const n = q.shift();
            res[res.length-1].push(n.val);
            if(n.left) q.push(n.left);
            if(n.right) q.push(n.right);
        }
    }
    return res;
};
```

时间 O(n)

空间 O(n)

## 8-8 LeetCode：94. 二叉树的中序遍历 

![image-20210104212400840](前端算法与数据结构.assets/image-20210104212400840.png)

**递归版本：**

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    const res = [];
    const rec = (n)=>{
        if(!n) return;
        rec(n.left);
        res.push(n.val);
        rec(n.right);
    };
    rec(root);
    return res;
};
```

**迭代版本：**

使用栈

```js
var inorderTraversal = function(root) {
    const res = [];
    const stack = [];
    let p = root;
    while(stack.length || p){
        while(p){
        stack.push(p);
        p = p.left;
        }
        const n = stack.pop();
        res.push(n.val);
        p = n.right;
    }
    return res;
};
```

## 8-9 LeetCode：112. 路径总和

![image-20210104212958915](前端算法与数据结构.assets/image-20210104212958915.png)

![image-20210104213237658](前端算法与数据结构.assets/image-20210104213237658.png)

![image-20210104213309071](前端算法与数据结构.assets/image-20210104213309071.png)

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {boolean}
 */
var hasPathSum = function(root, sum) {
    if(!root) return false;
    let res = false;
    const dfs = (n,s) =>{
        //console.log(n.val,s);
        if(!n.left && !n.right && s === sum){
            res = true;
        }
        if(n.left) dfs(n.left,s+n.left.val)
        if(n.right) dfs(n.right,s+n.right.val)
    }
    dfs(root,root.val);
    return res;
};
```

**时间** O（n）

**空间** 使用了递归的函数调用堆栈，O（n） n递归堆栈的高

* 最差情况 n = 节点数 O（n）
* 最好情况 树均匀分布 O（logn）

n是树的节点数

## 8-10 前端与树：遍历 JSON 的所有节点值 

```js
const json = {
  a:{b:{c:1}},
  d:[1,2],
};

const dfs = (n,path) =>{
  console.log(n,path);
  Object.keys(n).forEach(k =>{
    dfs(n[k],path.concat(k));
  })
}

dfs(json,[]);

```

![image-20210104214312067](前端算法与数据结构.assets/image-20210104214312067.png)

## 8-11 前端与树：渲染 Antd 中的树组件 

![image-20210104215152190](前端算法与数据结构.assets/image-20210104215152190.png)

# 第9章 图

## 9-1 图

<img src="前端算法与数据结构.assets/image-20210105101501558.png" alt="image-20210105101501558" style="zoom: 67%;" />

<img src="前端算法与数据结构.assets/image-20210105101557118.png" alt="image-20210105101557118" style="zoom:67%;" />

<img src="前端算法与数据结构.assets/image-20210105101605109.png" alt="image-20210105101605109" style="zoom:67%;" />

<img src="前端算法与数据结构.assets/image-20210105101624835.png" alt="image-20210105101624835" style="zoom:67%;" />

<img src="前端算法与数据结构.assets/image-20210105101659781.png" alt="image-20210105101659781" style="zoom:67%;" />

## 9-2 图的深度/广度优先遍历 

<img src="前端算法与数据结构.assets/image-20210105101741200.png" alt="image-20210105101741200" style="zoom:67%;" />

**DFS**

<img src="前端算法与数据结构.assets/image-20210105101936209.png" alt="image-20210105101936209" style="zoom:67%;" />

```js
const graph ={
  0:[1,2],
  1:[2],
  2:[0,3],
  3:[3]
};

module.exports = graph;
```

```js
const graph = require('./graph')

const visited = new Set();
const dfs = (n) =>{
  console.log(n);
  visited.add(n);
  graph[n].forEach(c => {
    if(!visited.has(c)){
      dfs(c);
    }
  })
}

dfs(2);
// 2 0 1 3
```

**BFS**

<img src="前端算法与数据结构.assets/image-20210105102423998.png" alt="image-20210105102423998" style="zoom:67%;" />

```js
const graph = require('./graph')

const visited = new Set();
const q = [2];//放入起始节点
visited.add(2);
while(q.length){
  const n = q.shift();
  console.log(n);
  graph[n].forEach(c => {
    if(!visited.has(c)){
      q.push(c);
      visited.add(c);
    }
  });
}
// 2 0 3 1
```



## 9-3 LeetCode：65. 有效数字

<img src="前端算法与数据结构.assets/image-20210105103001122.png" alt="image-20210105103001122" style="zoom:67%;" />

## 9-4 LeetCode：417. 太平洋大西洋水流问题

<img src="前端算法与数据结构.assets/image-20210105103316073.png" alt="image-20210105103316073" style="zoom: 80%;" />

<img src="前端算法与数据结构.assets/image-20210105103326049.png" alt="image-20210105103326049" style="zoom:80%;" />

<img src="前端算法与数据结构.assets/image-20210105103704025.png" alt="image-20210105103704025" style="zoom:67%;" />

<img src="前端算法与数据结构.assets/image-20210105103743185.png" alt="image-20210105103743185" style="zoom:67%;" />

```js
/**
 * @param {number[][]} matrix
 * @return {number[][]}
 */
var pacificAtlantic = function(matrix) {
    //排除意外情况(矩阵为空 or 不是二维矩阵)))
    if(!matrix || !matrix[0]) { return [];}
    //1.新建两个矩阵
    const m = matrix.length;
    const n = matrix[0].length;
    const flow1 = Array.from({length:m},() => new Array(n).fill(false));//二维矩阵
    const flow2 = Array.from({length:m},() => new Array(n).fill(false));
    //2. DFS
    const dfs = (r,c,flow) =>{
        flow[r][c] = true;
        [[r-1,c],[r+1,c],[r,c-1],[r,c+1]].forEach(([nr,nc])=>{
            if(
                //保证下一个节点在矩阵中
                nr >=0 && nr < m &&
                nc >=0 && nc < n &&
                //防止死循环
                !flow[nr][nc] &&
                //保证逆流而上
                matrix[nr][nc] >= matrix[r][c]
            ){
                dfs(nr,nc,flow);
            }
        });
    };
    //沿着海岸线逆流而上
    for(let r=0;r<m;r+=1){
        dfs(r,0,flow1);
        dfs(r,n-1,flow2);
    }
    for(let c=0;c<n;c+=1){
        dfs(0,c,flow1);
        dfs(m-1,c,flow2);
    }
    //3.收集能流到两个大洋的坐标
    const res = [];
    for(let r =0;r<m;r+=1){
        for(let c= 0;c<n;c+=1){
            if(flow1[r][c] && flow2[r][c]){
                res.push([r,c]);
            }
        }
    }
    return res;
};
```

思路解析：

1. 新建两个矩阵 flow1：能流到太平洋的坐标(能流到为true 不能为false) flow2：能流到大西洋的坐标
   * 新建一个m*n的填充值为false的数组 `const flow1 = Array.from({length:m},()=> new Array(n).fill(false)`
2. 沿海岸线DFS遍历图，填充矩阵
   * 太平洋海岸线：matrix(0,0) ~ marrix(0,m)  和 matirx(0,0) ~matirx(n-1,0) 大西洋海岸线 matrix(m-1,0) ~ marrix(m-1,n) 和 matrix(0,n-1) ~ marrix(m-1,n)
   * 遍历的时候某一点[r,c]的相邻节点有四个方向
3. 遍历两个矩阵，收集结果

时间：O(m*n)

空间：O(m*n)

## 9-5 LeetCode：133. 克隆图

![image-20210105105448496](前端算法与数据结构.assets/image-20210105105448496.png)

![image-20210105105609672](前端算法与数据结构.assets/image-20210105105609672.png)

![image-20210105105755051](前端算法与数据结构.assets/image-20210105105755051.png)

![image-20210105105813644](前端算法与数据结构.assets/image-20210105105813644.png)

![image-20210105105832862](前端算法与数据结构.assets/image-20210105105832862.png)

**DFS**

```js
/**
 * // Definition for a Node.
 * function Node(val, neighbors) {
 *    this.val = val === undefined ? 0 : val;
 *    this.neighbors = neighbors === undefined ? [] : neighbors;
 * };
 */

/**
 * @param {Node} node
 * @return {Node}
 */
var cloneGraph = function(node) {
    //排除特殊情况
    if(!node) return;
    //1.DFS
    const visited = new Map();
    const dfs = (n) => {
        //console.log(n.val);
        //2.拷贝节点存储起来
        const nCopy = new Node(n.val);
        visited.set(n,nCopy);
        (n.neighbors || []).forEach(ne =>{
            if(!visited.has(ne)){
                dfs(ne);
            }
            //3.连接
            nCopy.neighbors.push(visited.get(ne));
        })
    };
    dfs(node);
    return visited.get(node);
};
```

时间：O(n)

空间：O(n)

**BFS**

```js
/**
 * // Definition for a Node.
 * function Node(val, neighbors) {
 *    this.val = val === undefined ? 0 : val;
 *    this.neighbors = neighbors === undefined ? [] : neighbors;
 * };
 */

/**
 * @param {Node} node
 * @return {Node}
 */
var cloneGraph = function(node) {
    if(!node) return;
    //BFS
    const visited = new Map();
    const q = [node];
    visited.set(node,new Node(node.val));
    while(q.length){
        const n = q.shift();
        //console.log(n.val);
        (n.neighbors || []).forEach(ne =>{
            if(!visited.has(ne)){
                q.push(ne);
                //拷贝节点
                visited.set(ne,new Node(ne.val));
            }
            //拷贝边
            visited.get(n).neighbors.push(visited.get(ne));
        });
    }
    return visited.get(node);
};
```

时间：O(n) n是图的节点数

空间：O(n)

# 第10章 堆

<<<<<<< HEAD
## 10-1 堆简介

![image-20210115094712641](前端算法与数据结构.assets/image-20210115094712641.png)

![image-20210115094752588](前端算法与数据结构.assets/image-20210115094752588.png)

![image-20210115094805259](前端算法与数据结构.assets/image-20210115094805259.png)

![image-20210115094826358](前端算法与数据结构.assets/image-20210115094826358.png)

## 10-2 JS 实现：最小堆类 

![image-20210115094840667](前端算法与数据结构.assets/image-20210115094840667.png)

![image-20210115094912719](前端算法与数据结构.assets/image-20210115094912719.png)

![image-20210115094931191](前端算法与数据结构.assets/image-20210115094931191.png)

![image-20210115095019721](前端算法与数据结构.assets/image-20210115095019721.png)
=======
## 10-1 堆

![image-20210114203024765](前端算法与数据结构.assets/image-20210114203024765.png)

![image-20210114203157106](前端算法与数据结构.assets/image-20210114203157106.png)

![image-20210114203244610](前端算法与数据结构.assets/image-20210114203244610.png)

![image-20210114203312512](前端算法与数据结构.assets/image-20210114203312512.png)

## 10-2 JS实现：最小堆类 

![image-20210114203509000](前端算法与数据结构.assets/image-20210114203509000.png)

![image-20210114203629512](前端算法与数据结构.assets/image-20210114203629512.png)

```js
class MinHeap{
  constructor(){
    this.heap = [];
  }
  swap(i1,i2){
    const tmp = this.heap[i1];
    this.heap[i1] = this.heap[i2];
    this.heap[i2] = tmp;
  }
  getParentIndex(i){
    //return Math.floor((i-1)/2);
    return (i-1)>>1;
  }
  shiftUp(index){
    if(index == 0) { return;}
    const parentIndex = this.getParentIndex(index);
    if(this.heap[parentIndex]>this.heap[index]){
      this.swap(parentIndex,index);
      this.shiftUp(parentIndex);
    } 
  }
  insert(value){
    this.heap.push(value);
    this.shiftUp(this.heap.length-1);
  }
}

//测试
const h = new MinHeap();
h.insert(3);
h.insert(2);
h.insert(1);
console.log(h);//[1,3,2]
```

![image-20210114204922652](前端算法与数据结构.assets/image-20210114204922652.png)

```js
class MinHeap{
  constructor(){
    this.heap = [];
  }
  swap(i1,i2){
    const tmp = this.heap[i1];
    this.heap[i1] = this.heap[i2];
    this.heap[i2] = tmp;
  }
  getLeftIndex(i){
    return 2*i+1;
  }
  getRightIndex(i){
    return 2*i+2;
  }
  shiftDown(index){
    const leftIndex = this.getLeftIndex(index);
    const rightIndex = this.getRightIndex(index);
    if(this.heap[leftIndex]<this.heap[index]){
      this.swap(leftIndex,index);
      this.shiftDown(leftIndex);
    }
    if(this.heap[rightIndex]<this.heap[index]){
      this.swap(rightIndex,index);
      this.shiftDown(rightIndex);
    }
  }
  //删除节点
  pop(){
    this.heap[0] = this.heap.pop();
    this.shiftDown(0);
  }
}

//测试
const h = new MinHeap();
h.insert(3);
h.insert(2);
h.insert(1);
console.log(h);//[1,3,2]
h.pop();
console.log(h);//[2,3]
```

![image-20210114205334179](前端算法与数据结构.assets/image-20210114205334179.png)
>>>>>>> a298c86c6e773cf957d2e0923c82d09901effa89

```js
class MinHeap{
  constructor(){
    this.heap = [];
  }
  swap(i1,i2){
    const tmp = this.heap[i1];
    this.heap[i1] = this.heap[i2];
    this.heap[i2] = tmp;
  }
  getParentIndex(i){
    //return Math.floor((i-1)/2);
    return (i-1)>>1;
  }
  getLeftIndex(i){
    return 2*i+1;
  }
  getRightIndex(i){
    return 2*i+2;
  }
  shiftUp(index){
    if(index == 0) { return;}
    const parentIndex = this.getParentIndex(index);
    if(this.heap[parentIndex]>this.heap[index]){
      this.swap(parentIndex,index);
      this.shiftUp(parentIndex);
    } 
  }
  shiftDown(index){
    const leftIndex = this.getLeftIndex(index);
    const rightIndex = this.getRightIndex(index);
    if(this.heap[leftIndex]<this.heap[index]){
      this.swap(leftIndex,index);
      this.shiftDown(leftIndex);
    }
    if(this.heap[rightIndex]<this.heap[index]){
      this.swap(rightIndex,index);
      this.shiftDown(rightIndex);
    }
  }
  //插入 
  insert(value){
    this.heap.push(value);
    this.shiftUp(this.heap.length-1);
  }
  //删除节点
  pop(){
    this.heap[0] = this.heap.pop();
    this.shiftDown(0);
  }
  //获取堆顶
  peek(){
    return this.heap[0];
  }
  //获取堆的大小
  size(){
    return this.heap.length;
  }
}
<<<<<<< HEAD
```



## 10-3 LeetCode：215. 数组中的第 K 个最大元素 

![image-20210115095109411](前端算法与数据结构.assets/image-20210115095109411.png)

**解题思路：**

* 看到”第K个最大元素“
* 考虑使用最小堆

![image-20210115095229324](前端算法与数据结构.assets/image-20210115095229324.png)
=======

//测试
const h = new MinHeap();
h.insert(3);
h.insert(2);
h.insert(1);
console.log(h);//[1,3,2]
h.pop();
consolelog(h);//[2,3]
console.log(h.peek());//2
console.log(h.size());//2
```

## 10-3 LeetCode：215. 数组中的第 K 个最大元素 

思路：维护一个最小堆，将比堆顶大的元素插入。

![image-20210114205900104](前端算法与数据结构.assets/image-20210114205900104.png)

![image-20210114214951589](前端算法与数据结构.assets/image-20210114214951589.png)

![image-20210114215041373](前端算法与数据结构.assets/image-20210114215041373.png)
>>>>>>> a298c86c6e773cf957d2e0923c82d09901effa89

```js
class MinHeap{
  constructor(){
    this.heap = [];
  }
  swap(i1,i2){
    const tmp = this.heap[i1];
    this.heap[i1] = this.heap[i2];
    this.heap[i2] = tmp;
  }
  getParentIndex(i){
    //return Math.floor((i-1)/2);
    return (i-1)>>1;
  }
  getLeftIndex(i){
    return 2*i+1;
  }
  getRightIndex(i){
    return 2*i+2;
  }
  shiftUp(index){
    if(index == 0) { return;}
    const parentIndex = this.getParentIndex(index);
    if(this.heap[parentIndex]>this.heap[index]){
      this.swap(parentIndex,index);
      this.shiftUp(parentIndex);
    } 
  }
  shiftDown(index){
    const leftIndex = this.getLeftIndex(index);
    const rightIndex = this.getRightIndex(index);
    if(this.heap[leftIndex]<this.heap[index]){
      this.swap(leftIndex,index);
      this.shiftDown(leftIndex);
    }
    if(this.heap[rightIndex]<this.heap[index]){
      this.swap(rightIndex,index);
      this.shiftDown(rightIndex);
    }
  }
  //插入 
  insert(value){
    this.heap.push(value);
    this.shiftUp(this.heap.length-1);
  }
  //删除节点
  pop(){
    this.heap[0] = this.heap.pop();
    this.shiftDown(0);
  }
  //获取堆顶
  peek(){
    return this.heap[0];
  }
  //获取堆的大小
  size(){
    return this.heap.length;
  }
}

var findKthLargest = function(nums, k) {
  let h = new MinHeap();
  nums.forEach(n=>{
    h.insert(n);
    if(h.size()>k){
      h.pop();
    }
  });
  return h.peek();
};
```

<<<<<<< HEAD
## 10-4 LeetCode：347. 前 K 个高频元素

![image-20210115095322134](前端算法与数据结构.assets/image-20210115095322134.png)
=======
时间：O(n*log(k))

空间：O(k)

## 10-4 LeetCode：347. 前 K 个高频元素 

![image-20210114221716351](前端算法与数据结构.assets/image-20210114221716351.png)
>>>>>>> a298c86c6e773cf957d2e0923c82d09901effa89

**思路1 记录词频后排序**

利用map记录每个数字出现的次数，将其排序后输出前k个元元素。

```js
var topKFrequent = function(nums,k){
  const map = new Map();
  nums.forEach(n=>{
    map.set(n,map.has(n)?map.get(n)+1:1);
  });
  const list = Array.from(map).sort((a,b)=>b[1]-a[1]);
  console.log(list);
  //console.log(Array.from(map));
  return list.slice(0,k).map(n=>n[0]);
}
```

注意：

* map转数组利用`Array.from`

  ```js
  //Map { 4 => 1, 1 => 1, -1 => 2, 2 => 2, 3 => 1 }
  const list = Arrat.from(map);
  //list [ [ 4, 1 ], [ 1, 1 ], [ -1, 2 ], [ 2, 2 ], [ 3, 1 ] ]
  ```

* 数组排序用sort
<<<<<<< HEAD

=======
>>>>>>> a298c86c6e773cf957d2e0923c82d09901effa89
* 该算法 O(nlogn)

**思路2 优化版本**

使用堆

```js
class MinHeap{
  constructor(){
    this.heap = [];
  }
  swap(i1,i2){
    const tmp = this.heap[i1];
    this.heap[i1] = this.heap[i2];
    this.heap[i2] = tmp;
  }
  getParentIndex(i){
    //return Math.floor((i-1)/2);
    return (i-1)>>1;
  }
  getLeftIndex(i){
    return 2*i+1;
  }
  getRightIndex(i){
    return 2*i+2;
  }
  shiftUp(index){
    if(index == 0) { return;}
    const parentIndex = this.getParentIndex(index);
    if(this.heap[parentIndex].value>this.heap[index].value){
      this.swap(parentIndex,index);
      this.shiftUp(parentIndex);
    } 
  }
  shiftDown(index){
    const leftIndex = this.getLeftIndex(index);
    const rightIndex = this.getRightIndex(index);
    if(this.heap[leftIndex] && this.heap[leftIndex].value<this.heap[index].value){
      this.swap(leftIndex,index);
      this.shiftDown(leftIndex);
    }
    if(this.heap[rightIndex] && this.heap[rightIndex].value<this.heap[index].value){
      this.swap(rightIndex,index);
      this.shiftDown(rightIndex);
    }
  }
  //插入 
  insert(value){
    this.heap.push(value);
    this.shiftUp(this.heap.length-1);
  }
  //删除节点
  pop(){
    this.heap[0] = this.heap.pop();
    this.shiftDown(0);
  }
  //获取堆顶
  peek(){
    return this.heap[0];
  }
  //获取堆的大小
  size(){
    return this.heap.length;
  }
}

var topKFrequent = function(nums, k) {
  const map = new Map();
  nums.forEach(n=>{
    map.set(n,map.has(n)?map.get(n)+1:1);
  });
  const h = new MinHeap();
  map.forEach((value,key)=>{
      h.insert({value,key});
      if(h.size()>k){
          h.pop();
      }
  });
  return h.heap.map(a=>a.key);
};

```

注意：

* map的key和value

  ```js
  //Map { 4 => 1, 1 => 1, -1 => 2, 2 => 2, 3 => 1 }
  map.forEach((value,key)=>{
    console.log(value,key);
  })
  //1 4
  //1 1
  //2 -1
  //2 2
  //1 3
  map.forEach((n)=>{
     console.log(n);
  })
  //1
  //1
  //2
  //2
  //1
  ```

<<<<<<< HEAD
* 因为rightIndex是计算出来的，所以要先判断其是不是存在，`this.heap[rightIndex] && this.heap[rightIndex].value<this.heap[index].value`，存在后再进行比较，一个小技巧：使用`&&`

* 时间 O(n)  空间 O(n)

## 10-5 LeetCode：23. 合并K个排序链表

![image-20210115095559695](前端算法与数据结构.assets/image-20210115095559695.png)

![image-20210115095630910](前端算法与数据结构.assets/image-20210115095630910.png)

![image-20210115095646658](前端算法与数据结构.assets/image-20210115095646658.png)
=======
* ```js
  this.heap[leftIndex] && this.heap[leftIndex].value<this.heap[index].value
  ```

  因为leftIndex是计算出来的，不确定该索引上有没有值，所以要先进行判断，利用`&&`

* 时间 O(n)

* 空间 O(n)

## 10-5 LeetCode：23. 合并K个排序链表 

![image-20210114224450829](前端算法与数据结构.assets/image-20210114224450829.png)

<img src="前端算法与数据结构.assets/image-20210114224933954.png" alt="image-20210114224933954" style="zoom:50%;" />

<img src="前端算法与数据结构.assets/image-20210114225054368.png" alt="image-20210114225054368" style="zoom:50%;" />
>>>>>>> a298c86c6e773cf957d2e0923c82d09901effa89

```js
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
class MinHeap{
  constructor(){
    this.heap = [];
  }
  swap(i1,i2){
    const tmp = this.heap[i1];
    this.heap[i1] = this.heap[i2];
    this.heap[i2] = tmp;
  }
  getParentIndex(i){
    //return Math.floor((i-1)/2);
    return (i-1)>>1;
  }
  getLeftIndex(i){
    return 2*i+1;
  }
  getRightIndex(i){
    return 2*i+2;
  }
  shiftUp(index){
    if(index == 0) { return;}
    const parentIndex = this.getParentIndex(index);
    if(this.heap[parentIndex].val>this.heap[index].val){
      this.swap(parentIndex,index);
      this.shiftUp(parentIndex);
    } 
  }
  shiftDown(index){
    const leftIndex = this.getLeftIndex(index);
    const rightIndex = this.getRightIndex(index);
    if(this.heap[leftIndex] && this.heap[leftIndex].val<this.heap[index].val){
      this.swap(leftIndex,index);
      this.shiftDown(leftIndex);
    }
    if(this.heap[rightIndex] && this.heap[rightIndex].val<this.heap[index].val){
      this.swap(rightIndex,index);
      this.shiftDown(rightIndex);
    }
  }
  //插入 
  insert(value){
    this.heap.push(value);
    this.shiftUp(this.heap.length-1);
  }
  //删除节点
  pop(){
    if(this.size() === 1) return this.heap.shift();
    const top = this.heap[0];
    this.heap[0] = this.heap.pop();
    this.shiftDown(0);
    return top;
  }
  //获取堆顶
  peek(){
    return this.heap[0];
  }
  //获取堆的大小
  size(){
    return this.heap.length;
  }
}
var mergeKLists = function(lists) {
    const res = new ListNode(0);
    let p = res;
    //构建最小堆
    const h = new MinHeap();
    lists.forEach(l=>{
        if(l) h.insert(l);
    });
    while(h.size()){
        const n = h.pop();
        p.next = n;
        p = p.next;
        if(n.next) h.insert(n.next);
    }
    return res.next;
};
```

<<<<<<< HEAD
* 时间：O(nlogk) 空间：O(k)

# 第11章 进阶算法之“搜索排序”

## 11-1 排序和搜索简介

## 11-2 JS 实现：冒泡排序 

## 11-3 JS 实现：选择排序 

## 11-4 JS 实现：插入排序 

## 11-5 JS 实现：归并排序

## 11-6 JS 实现：快速排序 

## 11-7 JS 实现：顺序搜索

## 11-8 JS 实现：二分搜索 

## 11-9 LeetCode：21. 合并两个有序链表 

## 11-10 LeetCode：374. 猜数字大小 

## 11-11 排序与搜索-章节总结 11-12 思考题



##### 第12章 算法设计思想之“分而治之”

从本章开始我们就要进入算法设计学习阶段啦！分而治之的口诀一旦背下来，解题只在瞬息之间！还在等什么，快来享受学习的乐趣！

共 7 节 (42分钟) 收起列表

-  12-1 分而治之简介 (05:20)
-  12-2 LeetCode：374. 猜数字大小 (08:03)
-  12-3 LeetCode：226. 翻转二叉树 (11:20)
-  12-4 LeetCode：100. 相同的树 (07:56)
-  12-5 LeetCode：101. 对称二叉树 (07:13)
-  12-6 分而治之-章节总结 (01:26)
-  12-7 【勤于思考，夯实学习成果】阶段思考题
=======
* 时间 O(n*logk)
* 空间 O(k)

## 10-6 堆-章节总结 





# 第11章 进阶算法之“搜索排序”

面试中还不会手写快排、归并和二分？别急，快来跟着老师学套路，轻松搞定经典排序与搜索算法。

共 12 节 (115分钟) 收起列表

-  11-1 排序和搜索简介 (02:57)
-  11-2 JavaScript 实现：冒泡排序 (13:29)
-  11-3 JavaScript 实现：选择排序 (14:25)
-  11-4 JavaScript 实现：插入排序 (16:12)
-  11-5 JavaScript 实现：归并排序 (16:28)
-  11-6 JavaScript 实现：快速排序 (12:59)
-  11-7 JavaScript 实现：顺序搜索 (03:48)
-  11-8 JavaScript 实现：二分搜索 (11:20)
-  11-9 LeetCode：21. 合并两个有序链表 (11:16)
-  11-10 LeetCode：374. 猜数字大小 (09:21)
-  11-11 排序与搜索-章节总结 (02:44)
-  11-12 【勤于思考，夯实学习成果】阶段思考题

- 

  ##### 第12章 算法设计思想之“分而治之”

  从本章开始我们就要进入算法设计学习阶段啦！分而治之的口诀一旦背下来，解题只在瞬息之间！还在等什么，快来享受学习的乐趣！

  共 7 节 (42分钟) 收起列表

  -  12-1 分而治之简介 (05:20)
  -  12-2 LeetCode：374. 猜数字大小 (08:03)
  -  12-3 LeetCode：226. 翻转二叉树 (11:20)
  -  12-4 LeetCode：100. 相同的树 (07:56)
  -  12-5 LeetCode：101. 对称二叉树 (07:13)
  -  12-6 分而治之-章节总结 (01:26)
  -  12-7 【勤于思考，夯实学习成果】阶段思考题
>>>>>>> a298c86c6e773cf957d2e0923c82d09901effa89

- 

  ##### 第13章 算法设计思想之“动态规划”

  斐波那契数列问题、爬楼梯问题……无数经典问题都可以用动态规划来解！还在等什么，快来听老司机讲经~~

  共 5 节 (38分钟) 收起列表

  -  13-1 动态规划简介 (05:52)
  -  13-2 LeetCode：70. 爬楼梯 (12:49)
  -  13-3 LeetCode：198. 打家劫舍 (16:40)
  -  13-4 动态规划-章节总结 (01:46)
  -  13-5 【勤于思考，夯实学习成果】阶段思考题

- 

  ##### 第14章 算法设计思想之“贪心算法”

  “贪婪”是人的本性，也是算法的精华。干嘛要想得很远？快来看看，贪心算法如何带你今朝有酒今朝醉！

  共 5 节 (25分钟) 收起列表

  -  14-1 贪心算法简介 (04:24)
  -  14-2 LeetCode：455. 分饼干 (09:42)
  -  14-3 LeetCode：122. 买卖股票的最佳时机 II (09:02)
  -  14-4 贪心算法-章节总结 (01:19)
  -  14-5 【勤于思考，夯实学习成果】阶段思考题

- 

  ##### 第15章 算法设计思想之“回溯算法”

  遇到岔路，先选择一条路走，走不通拐回来走另一条路，直到走通为止。所谓“拐回来”，就是回溯。听起来很高大上？不不不，很简单，来听听老司机怎样逐步剖析吧！

  共 6 节 (42分钟) 收起列表

  -  15-1 回溯算法简介 (06:16)
  -  15-2 LeetCode：46. 全排列 (12:23)
  -  15-3 LeetCode：78. 子集 (11:46)
  -  15-4 回溯算法-章节总结 (03:03)
  -  15-5 回顾与总结 (07:54)
  -  15-6 【勤于思考，夯实学习成果】阶段思考题