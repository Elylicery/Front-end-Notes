第1章 课程介绍

本章会出几个面试题，分析每道题目设计的知识点，然后总结出一个完整的知识体系。让我们开始 “题目->知识点->解题” 的快乐之旅吧。

## 1-1 导学

**问题1 - 如何能"快速搞定"**

* 解决方案：直击重点！
* 快速圈出前端常见考点和题目
* 以最易理解的方式讲解清楚

<img src="img/image-20201109204819065.png" alt="image-20201109204819065" style="zoom:50%;" />

**问题2 - 如何做到”最易理解“**

* 讲知识点，不是题海战术
* 学会一道题，就能应对一类题
* 构建前端知识体系

<img src="img/image-20201109204935432.png" alt="image-20201109204935432" style="zoom:50%;" />

<img src="img/image-20201109204951334.png" alt="image-20201109204951334" style="zoom:50%;" />

资料：前端思维导图

**问题3 - 如何做到"匹配大厂"？**

* 大厂偏爱考察基础，特别是对于工作经验少的候选人
* 课程能讲解大厂一面的常见考点和面试题

**讲授方式**

* 先出面试题，引导思考
* 通过题目引出知识点，扩充知识体系
* 问题解答

##  1-2 看了这节课你就知道该怎么准备面试了

**关于面试**

* 基层工程师：基础知识
* 高级工程师：基础知识+项目经验
* 架构师：解决方案能力

**关于基础**

* 工程师的自我修养：基础知识
* 扎实的基础能让你高校学习新技术

##  1-3 先来体验几个面试题

**几个面试题**

* 出题
* 思考

<img src="img/image-20201109205719408.png" alt="image-20201109205719408" style="zoom:50%;" />

<img src="img/image-20201109205752883.png" alt="image-20201109205752883" style="zoom:50%;" />

## 1-4 如何搞定所有面试题

<img src="img/image-20201109210113232.png" alt="image-20201109210113232" style="zoom:50%;" />

<img src="img/image-20201109210315636.png" alt="image-20201109210315636" style="zoom: 67%;" />

<img src="img/image-20201109210343957.png" alt="image-20201109210343957" style="zoom: 67%;" />

<img src="img/image-20201109210353082.png" alt="image-20201109210353082" style="zoom: 67%;" />

<img src="img/image-20201109210425343.png" alt="image-20201109210425343" style="zoom:67%;" />

<img src="img/image-20201109210455760.png" alt="image-20201109210455760" style="zoom: 67%;" />

<img src="img/image-20201109210517155.png" alt="image-20201109210517155" style="zoom:67%;" />

##  1-5 知识体系

**前端知识体系**

* 什么是知识体系
* 从哪些方面梳理
* 知识体系

**什么是知识体系？**

* 高效学习三部曲：找准知识体系；刻意训练；及时反馈；
* 知识体系：结构化的知识范围
* 涵盖所有知识点；结构化、有组织、易扩展

**从哪些方面梳理**

* W3C标准
* ECMA 262标准
* 开发环境
* 运行环境

**知识体系**

* CSS基础知识
* JS基础语法
* JS-Web-API
* 开发环境
* 运行环境
* HTTP协议

# 第2章 面试前的准备

**本章主要内容**

* 面试的环节和流程
* JD分析
* 如何写简历
* 准备工作和注意事项

## 2-1 面试之前需要你准备什么

**面试的环节和流程**

* 什么是面试
* 如何拿到简历
* 面试流程

**什么是面试**

* 经过组织者精心设计
* 以交谈和观察为主要手段
* 评价知识、能力和经验，综合素质

## 2-2 投递简历的几种方式

**如何拿到简历**

* 员工内推
* 猎头推荐
* hr收集（主动搜索，接收邮件）

## 2-3 面试的主要环节

**面试流程**

* 一面：以基础知识为主
* 二面（交叉面试）：从基础知识开始，考察原理，终于项目经验（要有实践经验辅助）
* 三面：不是纯技术，项目leader讲角色定位，产品的想法，未来技术规划
* hr面试：阿里hr有一票否决权；如实回答，阳光积极大方

**校招和社招的区别**

* 校招看中基础知识和能力，主要在一面
* 社招看中经验，主要在二面（基础知识要过关）
* 社招，工作时间越长，越偏重经验

## 2-4 JD分析-知己知彼

**JD分析**

* JD是什么
* JD分析的思路
* 案例

**JD是什么？**

* JD是用人单位发布的招聘信息
* 职位描述
* 岗位要求

**从JD中能看到什么？**

* 工作内容
* 技术栈
* 经验要求

**不要过于在意JD**

* JD是hr发布的
* hr和技术人员可能会沟通不及时
* 不能完全相信JD的要求

![image-20201110111154212](img/image-20201110111154212.png)

![image-20201110111639081](img/image-20201110111639081.png)

![image-20201110111927453](img/image-20201110111927453.png)

![image-20201110112200414](img/image-20201110112200414.png)

## 2-5 如何写简历

**如何写简历**

* 简历包含的内容
* 简历中需要注意的内容
* 案例

**划重点**

* 简历就像高考作文——阅卷时间非常短
* 内容简介
* 直击重点，表现出自己的优势

**简历包含的内容**

* 个人信息
* 教育经历
* 专业技能
* 工作经历
* 项目经历

**简历内容 - 基本信息**

* 必备：姓名 性别 电话 邮箱 籍贯
* 年龄可不写（能从教育经历评估出来）
* 头像无所谓

**简历内容 - 教育经历**

* 写上最高学历即可
* 学校，专业，入学和毕业时间

**简历内容 - 专业技能**

* 表现出自己的核心竞争力
* 内容不要太多，3、5条即可
* 太基础的不要写，例如会用vscode

**简历内容 - 工作经历**

* 如实写
* 写明公司，职位，入职离职时间即可，多写无益
* 如果有空窗期，如实写明即可

**简历内容 - 项目经历**

* 写2-4个具有说服力项目（视工作时间）
* 项目描述，技术栈，个人角色
* 技巧：可以把别人的项目写上，只要你能hold住

**简历内容 - 博客或开源**

* 有博客或者开源作品，会让你更有竞争力
* 切记：需要真的有内容，不可临时抱佛脚
* 可以从现在开始，慢慢积累

**注意事项**

* 界面不要太花哨，简洁明了即可
* 注意用词,"精通"，"熟练"等慎用
* 不可造假，会被拉入黑名单（项目经历那里，不是造假！！！）

## 2-6 面试前准备工作和注意事项

**面试前的准备工作**

* 看JD，是否需要临时准备一下
* 打印纸质简历，带着纸和笔
* 最好带着自己的电脑，现场可能手写代码

**面试前的注意事项**

* 要有时间观念，如果迟到或者推迟，要提前说
* 衣着适当，不用正装，也不要太随意
* 为何离职？ —— 不要吐槽前东家，说自己的原因
* 能加班吗？ —— 能！除非你特别自信，能找到其他机会
* 不要挑战面试官，即使他错了
* 遇到不会的问题，要表现出自己积极的一面（不会的题也积极表现出想知道）

**其他情况**

https://www.imooc.com/article/300475

# 第3章 CSS 面试题

## 3-1 html、css面试介绍

<img src="img/image-20201111213807774.png" alt="image-20201111213807774" style="zoom:67%;" />

<img src="img/image-20201112174053225.png" alt="image-20201112174053225" style="zoom:67%;" />

<img src="img/image-20201112174137603.png" alt="image-20201112174137603" style="zoom:67%;" />

<img src="img/image-20201112174233544.png" alt="image-20201112174233544" style="zoom: 67%;" />

<img src="img/image-20201112174309761.png" alt="image-20201112174309761" style="zoom:67%;" />

<img src="img/image-20201112174333424.png" alt="image-20201112174333424" style="zoom:67%;" />

<img src="img/image-20201112174352963.png" alt="image-20201112174352963" style="zoom:67%;" />

![image-20201112174404978](img/image-20201112174404978.png)

备注：CSS3动画并不是面试重点，除非是相关岗位

## 3-2 html面试题

### • 如何理解HTML语义化

<img src="img/image-20201112193930577.png" alt="image-20201112193930577" style="zoom:67%;" />

* 让人更容易读懂（增加代码可读性）
* 让搜索引擎更容易读懂（利于SEO即搜索引擎优化）

### • 块级元素&内联元素

* `display: block/table` 有 div h1 h2 table ul ol p等
* `display:inline/inline-block` 有span img input button等

## 3-3 布局

### • 盒子模型

<img src="img/image-20201112194517479.png" alt="image-20201112194517479" style="zoom:80%;" />

* offsetWidth = (内容宽度+内边距+边框)，无外边距
* 答案：122px
* 补充：如果让offetWidth等于100px，该如何做？设置`box-sizing:border-box，`document.getElementById('div1').offset` 就等于100px了

### • margin纵向重叠

<img src="img/image-20201112194555061.png" alt="image-20201112194555061" style="zoom:80%;" />

* 相邻元素的margin-top和margin-bottom会发生重叠
* 空白内容的`<p></p>`也会重叠
* 答案：15px

### • margin负值问题

<img src="img/image-20201112194657069.png" alt="image-20201112194657069" style="zoom:80%;" />

* margin-top和margin-left负值，元素向上，向左移动
* margin-right负值，右侧元素左移，自身不受影响
* margin-bottom负值，下方元素上移，自身不受影响

### • BFC

<img src="img/image-20201112194737742.png" alt="image-20201112194737742" style="zoom: 80%;" />

* Block format context，块级格式化上下文
* BFC是一块独立渲染区域，内部元素的渲染不会影响边界以外的元素
* 形成BFC的常见条件
  1. float不是none
  2. position是absolute或fixed
  3. overflow不是visible
  4. display是flex inline-block等
* BFC的常见应用
  * 清除浮动

**BFC清除浮动代码示例**

不清楚浮动：

![image-20201210202144862](img/image-20201210202144862.png)

清除浮动：

```html
    <style type="text/css">
        .container {
            background-color: #f1f1f1;
        }
        .left {
            float: left;
        }
        .bfc {
            overflow: hidden; /* 触发元素 BFC */
        } 
    </style>
</head>
<body>
    <div class="container bfc">
        <img src="https://www.imooc.com/static/img/index/logo.png" class="left" style="magin-right: 10px;"/>
        <p class="bfc">某一段文字……</p>
    </div>
</body>
```

<img src="img/image-20201112201252151.png" alt="image-20201112201252151" style="zoom:80%;" />

### • float布局

<img src="img/image-20201112194850601.png" alt="image-20201112194850601" style="zoom:80%;" />

**圣杯布局和双飞翼布局的目的**

* 三栏布局，中间一栏最先加载和渲染（内容最重要）
* 两侧内容固定，中间内容随着宽度自适应
* 一般用于PC网页

<img src="img/image-20201112201450006.png" alt="image-20201112201450006" style="zoom: 67%;" />

**圣杯布局和双飞翼布局的技术总结**

* 使用float布局
* 两侧使用margin负值，以便和中间内容横向重叠
* 防止中间内容被两侧覆盖，一个用padding（圣杯布局）一个用margin（双飞翼布局）

**圣杯布局代码**

![image-20201114203103858](img/image-20201114203103858.png)

```html
<body>
    <div id="header">this is header</div>
    <div id="container">
        <div id="center" class="column">this is center</div>
        <div id="left" class="column">this is left</div>
        <div id="right" class="column">this is right</div>
    </div>
    <div id="footer">this is footer</div>
</body>
```

```css
<style type="text/css">
        body {
            min-width: 550px;
        }
        #header {
            text-align: center;
            background-color: #f1f1f1;
        }
        #container{
          padding-left: 200px;
          padding-right: 150px;/*1.留出中间的内容*/
        }
        #container .column{
          float: left;/*2.设置float布局*/
        }
        #center {
            background-color: #ccc;
            width: 100%;
        }
        #left {
            background-color: yellow;
            width: 200px;
            margin-left: -100%;/*3.left的父元素的宽度值，设置负值，以便和中间内容横向重叠*/
            position: relative;
            right: 200px;/*position为relative就是相对自身移动元素*/
        }
        #right {
            background-color: red;
            width: 150px;
            margin-right: -150px;/*4.margin负值*/
        }
        #footer {
          clear: both;/*清除浮动*/
          text-align: center;
          background-color: #f1f1f1;
        }
    </style>
```

**双飞翼代码**（推荐，更简单）

![image-20201114203103858](img/image-20201114203103858-1607604791007.png)

```html
<body>
  <div id="header">this is header</div>
  <div id="container">
      <div id="center" class="column">
        <!--注意这里加了个center-wrap-->
        <div id="center-wrap">
          this is center
        </div>
      </div>
      <div id="left" class="column">this is left</div>
      <div id="right" class="column">this is right</div>
  </div>
  <div id="footer">this is footer</div>
</body>
```

```css
  <style type="text/css">
  #header{
    text-align: center;
    background-color: #f1f1f1;
  }
  .column{
    float: left;
  }
  #center{
    background-color: #ccc;
    width: 100%;
  }
  #center-wrap{
    margin: 0 150px 0 200px;
  }
  #left{
    width: 200px;
    margin-left: -100%;/*margin-left负值100%*/
    background-color: yellow;
  }
  #right{
    width: 150px;
    margin-left: -150px;/*margin-left负值自身宽度*/
    background-color: red;
  }
  #footer{
    clear: both;
    text-align: center;
    background-color: #f1f1f1;
  }
  </style>
```

**清除浮动代码**

```html
    <div id="container" class="clearfix">
        <div id="center" class="column">this is center</div>
        <div id="left" class="column">this is left</div>
        <div id="right" class="column">this is right</div>
    </div>
```

```js
        /* 手写 clearfix */
        .clearfix:after {
            content: '';
            display: table;
            clear: both;
        }
```

<img src="img/image-20201114211118267.png" alt="image-20201114211118267" style="zoom: 80%;" />

### • flex布局

<img src="img/image-20201112194858629.png" alt="image-20201112194858629" style="zoom:80%;" />

**常用语法回顾：**

* `flex-direction`属性决定主轴的方向
* `flex-wrap`属性定义，如果一条轴线排不下，如何换行。
* `justify-content`属性定义了项目在主轴上的对齐方式。
* `align-items`属性定义项目在交叉轴上如何对齐
* `align-self`属性允许单个项目有与其他项目不一样的对齐方式，可覆盖

<img src="img/image-20201117092928509.png" alt="image-20201117092928509"  />

代码：

![image-20201210212047823](img/image-20201210212047823.png)

```html
<!DOCTYPE html>
<html lang="en">
	<head>
		<style type="text/css">
			*{
        padding: 0px;
        margin: 0px;
      }
      .box{
        margin: 0 auto;
        width: 200px;
        height: 200px;
        border: 5px solid lightcoral;
        padding: 10px;
        border-radius: 50px;
        /*flex布局*/
        display: flex;
        justify-content: space-between;

      }
      .item{
        width: 50px;
        height: 50px;
        background-color: lightcoral;
        border-radius: 25px;
      }
      .item:nth-child(2){
        align-self: center;/*设置align-self*/
      }
      .item:nth-child(3){
        align-self: flex-end;/*设置align-self*/
      }
		</style>
	</head>
	<body>
		<div class="box">
      <div class="item"></div>
      <div class="item"></div>
      <div class="item"></div>
    </div>
  </body>
</html>

```



## 3-4 定位

### • relative分别依据什么定位？

![image-20201117093135371](img/image-20201117093135371.png)

![image-20201117093151231](img/image-20201117093151231.png)

```html
<body>
    <p>absolute 和 relative 定位问题</p>
    <div class="relative">
        <div class="absolute">
            this is absolute
        </div>
    </div>
</body>
```

```css
 <style type="text/css">
        body {
            margin: 20px;
        }
        .relative {
            position: relative;
            width: 400px;
            height: 200px;
            border: 1px solid #ccc;
        }
        .absolute {
            position: absolute;
            width: 200px;
            height: 100px;
            border: 1px solid blue;
            top: 20px;/*依据relative的元素定位*/
            left: 50px;
        }
    </style>
```

![image-20201117093318082](img/image-20201117093318082.png)

```css
 <style type="text/css">
        body {
            margin: 20px;
        }
        .relative {
            position: relative;
            width: 400px;
            height: 200px;
            border: 1px solid #ccc;
            top: 20px;/*依据自身定位*/
            left: 50px;
        }
        .absolute {
            position: absolute;
            width: 200px;
            height: 100px;
            border: 1px solid blue;
            top: 20px;
            left: 50px;
        }
    </style>
```

![image-20201117093334332](img/image-20201117093334332.png)

```css
    <style type="text/css">
        body {
            margin: 20px;
        }
        .relative {
            width: 400px;
            height: 200px;
            border: 1px solid #ccc;
        }
        .absolute {
            position: absolute;
            width: 200px;
            height: 100px;
            border: 1px solid blue;
            top: 20px;/*依据body定位*/
            left: 50px;
        }
    </style>
```

![image-20201117093508946](img/image-20201117093508946.png)

### • 居中对齐的实现方式

包括：水平居中 和 垂直居中

**水平居中**

![image-20201117093644987](img/image-20201117093644987.png)

* inline元素：`text-align:center`

  ```html
      <div class="container container-1">
          <span>一段文字</span>
      </div>
  ```

  ```css
          .container {
              border: 1px solid #ccc;
              margin: 10px;
              padding: 10px;
          }
  
          .container-1 {
              text-align: center;/*水平居中*/
          } 
  ```

  ![image-20201117094323972](img/image-20201117094323972.png)

* block元素：`margin:auto`

  ```html
      <div class="container container-2">
          <div class="item">
              this is block item
          </div>
      </div>
  ```

  ```css
  		.container {
              border: 1px solid #ccc;
              margin: 10px;
              padding: 10px;
          }
          .container-2 .item {
              background-color: #ccc;
              width: 500px;
              margin: auto;/*水平居中*/
          }
  ```

  ![image-20201117094332120](img/image-20201117094332120.png)

* absolute元素:`left:50% + margin-left负值`

  ```html
      <div class="container container-3">
          <div class="item">
              this is absolute item
          </div>
      </div>
  ```

  ```css
          .container {
              border: 1px solid #ccc;
              margin: 10px;
              padding: 10px;
          }
          .container-3 {
              position: relative;
              height: 100px;
          }
          .container-3 .item {
            	background-color: #ccc;
              width: 300px;
              height: 100px;
              position: absolute;
              left: 50%;
              margin-left: -150px;/*需要知道子元素宽度*/
          }
  ```
  

![image-20201117094341390](img/image-20201117094341390.png)

**垂直居中**

![image-20201117093705486](img/image-20201117093705486.png)

* inline元素：`line-height的值等于height值`

  ```html
      <div class="container container-1">
          <span>一段文字</span>
      </div>
  ```

  ```css
  .container {
              border: 1px solid #ccc;
              margin: 10px;
              padding: 10px;
              height: 200px;
          }
          .container-1{
              text-align: center;
              height: 200px;/*line-height的值等于height值*/
              line-height: 200px;
          }
  ```

  ![image-20201117094852531](img/image-20201117094852531.png)

* absolute元素：`top 50% + margin-top负值`

  ```html
      <div class="container container-2">
          <div class="item">
              this is item
          </div>
      </div>
  ```

  ```css
          .container-2 {
              position: relative;
          }
          .container-2 .item {
              background-color: #ccc;
              width: 300px;
              height: 100px;
              position: absolute;
              left: 50%;
              margin-left: -150px;
              top: 50%;
              margin-top: -50px;
          }
  ```

  ![image-20201117094930393](img/image-20201117094930393.png)

* absolute元素：`transform(-50%.-50%)`

  ```html
      <div class="container container-3">
          <div class="item">
              this is item
          </div>
      </div>
  ```

  ```css
          .container-3 {
              position: relative;
          }
          .container-3 .item {
              background-color: #ccc;
              width: 200px;
              height: 80px;
              position: absolute;
              left: 50%;
              top: 50%;
              transform: translate(-50%, -50%)
          }
  ```

  ![image-20201117095002938](img/image-20201117095002938.png)

* absolute元素：`top left bottom right = 0 + margin : auto`

  注意：这个不需要知道子元素的高宽

  ```html
      <div class="container container-4">
          <div class="item">
              this is item
          </div>
      </div>
  ```

  ```css
          .container-4 {
              position: relative;
          }
          .container-4 .item {
             background-color: #ccc;
              width: 100px;
              height: 50px;
              position: absolute;
              top: 0;
              left: 0;
              bottom: 0;
              right: 0;
              margin: auto;
          }
  ```

  ![image-20201117095059616](img/image-20201117095059616.png)



## 3-5  图文样式

### • line-height

![image-20201117095148395](img/image-20201117095148395.png)

![image-20201117095204904](img/image-20201117095204904.png)

![image-20201117095220144](img/image-20201117095220144.png)

```html
<style type="text/css">
        body {
            font-size: 20px;
            line-height: 200%;
        }
        p {
            background-color: #ccc;
            font-size: 16px;
        }
    </style>
<body>
    <p>这是一行文字</p>
</body>

```

<img src="img/image-20201117095321096.png" alt="image-20201117095321096" style="zoom:67%;" />

## 3-6 响应式

### • rem

<img src="img/image-20201117095757268.png" alt="image-20201117095757268" style="zoom:80%;" />

### • 响应式布局的常见方案

<img src="img/image-20201117095831565.png" alt="image-20201117095831565" style="zoom:80%;" />

```html
<html>
<head>
    <title>响应式布局</title>
    <style type="text/css">
        @media only screen and (max-width: 374px) {
            /* iphone5 或者更小的尺寸，以 iphone5 的宽度（320px）比例设置 font-size */
            html {
                font-size: 86px;
            }
        }
        @media only screen and (min-width: 375px) and (max-width: 413px) {
            /* iphone6/7/8 和 iphone x */
            html {
                font-size: 100px;
            }
        }
        @media only screen and (min-width: 414px) {
            /* iphone6p 或者更大的尺寸，以 iphone6p 的宽度（414px）比例设置 font-size */
            html {
                font-size: 110px;
            }
        }
        body {
            font-size: 0.16rem;
        }
        #div1 {
            width: 1rem;
            background-color: #ccc;
        }
    </style>
</head>
<body>
    <div id="div1">
        this is div
    </div>
</body>
</html>
```

### • vw-wh

**rem的弊端**

<img src="img/image-20201117100119536.png" alt="image-20201117100119536" style="zoom:80%;" />

**网页视口尺寸**

<img src="img/image-20201117100225664.png" alt="image-20201117100225664" style="zoom:80%;" />

<img src="img/image-20201117100257516.png" alt="image-20201117100257516" style="zoom:80%;" />

667 是screen.height 屏幕高度

553 innerHieght

**vw/vh**

![image-20201117100433099](img/image-20201117100433099.png)

# 第4章 JS基础-变量类型和计算

## 4-1 JS 值类型和引用类型

<img src="img/image-20201117170503666.png" alt="image-20201117170503666" style="zoom: 67%;" />

![image-20201117171030270](img/image-20201117171030270.png)

<img src="img/image-20201117170534401.png" alt="image-20201117170534401" style="zoom: 67%;" />

![image-20201117170839874](img/image-20201117170839874.png)

**值**类型在**栈**中存储。**引用**类型在**堆**中申请内存地址

栈是从上往下累加。堆是从下往上排列，一般情况不会重合。

<img src="img/image-20201117171153679.png" alt="image-20201117171153679" style="zoom:67%;" />

<img src="img/image-20201117171242506.png" alt="image-20201117171242506" style="zoom:67%;" />

### • typeof能判断哪种类型

* 识别所有值类型
* 识别函数
* 判断是否是引用类型（不可再细分）

<img src="img/image-20201117172425897.png" alt="image-20201117172425897" style="zoom:67%;" />

<img src="img/image-20201117172453518.png" alt="image-20201117172453518" style="zoom:67%;" />

**补充：**

```js
console.log(typeof NaN);//number
console.log(typeof Function);//function
console.log(typeof Object);//function
console.log(typeof {});//object
console.log('a'+1);//a1
console.log('a'-1);//NaN
console.log(Function instanceof Object)//true
console.log(Object instanceof Function);//true
```



### • 何时使用 === 何时使用 == 

<img src="img/image-20201117211942829.png" alt="image-20201117211942829" style="zoom: 67%;" />

### • 值类型和引用类型的区别

<img src="img/image-20201117212000526.png" alt="image-20201117212000526" style="zoom:67%;" />

## 4-2 JS 深拷贝

### • 手写深拷贝

* 注意判断值类型还是引用类型
* 注意判断是数组还是对象
* 递归

如何实现引用类型（针对对象和数组）的深拷贝？

> 补充：
>
> * **Object.keys方法**
>   * 成员是参数对象自身的（不含继承的）所有可遍历（ enumerable ）属性的键名。
>   * 不可遍历原型链上的可枚举属性
> * for...in（深拷贝使用这种方法）
>   * 循环对象的所有枚举属性(包括原型上)，然后再使用hasOwnProperty()方法来忽略继承属性;

```js
/**
 * 深拷贝
 * @param {Object} obj 要拷贝的对象
 */
function deepClone(obj = {}) {
	if (typeof obj !== "object" || obj == null) {
		// obj 是 null ，或者不是对象和数组，直接返回
		return obj;
	}
	// 初始化返回结果
	let result;
	if (obj instanceof Array) {
		result = [];
	} else {
		result = {};
	}
	for (let key in obj) {
		// 保证 key 不是原型的属性
		if (obj.hasOwnProperty(key)) {
			// 递归调用！！！
			result[key] = deepClone(obj[key]);
		}
	}
	// 返回结果
	return result;
}
```

```js
/*eg*/
const obj1 = {
	age: 20,
	name: "xxx",
	address: {
		city: "beijing",
	},
	arr: ["a", "b", "c"],
};

const obj2 = deepClone(obj1);
obj2.address.city = "shanghai";
obj2.arr[0] = "a1";
console.log(obj1.address.city);//beijing
console.log(obj1.arr[0]);//a
```



## 4-3 变量计算 - 注意某些类型转换的坑

**变量计算 - 类型转换** 

知识点

* 字符串拼接
*  == 
* if语句和逻辑运算

![image-20201117210955324](img/image-20201117210955324.png)

<img src="img/image-20201117211056677.png" alt="image-20201117211056677" style="zoom:67%;" />

<img src="img/image-20201117211151019.png" alt="image-20201117211151019" style="zoom:67%;" />

<img src="img/image-20201117211324304.png" alt="image-20201117211324304" style="zoom:67%;" />

注意：实际工作中，除了判断null和undefined，一般都用 === 

<img src="img/image-20201117211523832.png" alt="image-20201117211523832" style="zoom:67%;" />

<img src="img/image-20201117211652706.png" alt="image-20201117211652706" style="zoom:67%;" />

<img src="img/image-20201117211738659.png" alt="image-20201117211738659" style="zoom:67%;" />

<img src="img/image-20201117211846367.png" alt="image-20201117211846367" style="zoom:67%;" />



## 4-4 小结

* 值类型 vs 引用类型，堆栈模型，深拷贝
* typeof运算符
* 类型转换，truly和falsely变量

# 第5章 JS基础-原型和原型链

本章介绍原型、原型链和 class 相关的知识点和题目。包括 class ，继承，原型，原型链，instanceof。原型是“JS 三座大山”之一，原型和原型链也是必考知识点。

## 5-1 JS 原型的考点和面试题

<img src="img/image-20201117213746936.png" alt="image-20201117213746936" style="zoom: 80%;" />

<img src="img/image-20201117213810766.png" alt="image-20201117213810766" style="zoom:80%;" />

## 5-2 如何用 class 实现继承

**class**

* constructor
* 属性
* 方法

**代码演示**

```js
// 类
class Student {
	constructor(name, number) {
		this.name = name;
		this.number = number;
	}
	sayHi() {
		console.log(`姓名 ${this.name} ，学号 ${this.number}`);
	}
}

// 通过类 new 对象/实例
const xialuo = new Student("夏洛", 100);
console.log(xialuo.name);
console.log(xialuo.number);
xialuo.sayHi();
```

**继承**

* extends
* super
* 扩展或重写方法

**代码演示**

```js
// 父类
class People {
    constructor(name) {
        this.name = name
    }
    eat() {
        console.log(`${this.name} eat something`)
    }
}
// 子类
class Student extends People {
    constructor(name, number) {
        super(name)
        this.number = number
    }
    sayHi() {
        console.log(`姓名 ${this.name} 学号 ${this.number}`)
    }
}
// 子类
class Teacher extends People {
    constructor(name, major) {
        super(name)
        this.major = major
    }
    teach() {
        console.log(`${this.name} 教授 ${this.major}`)
    }
}
// 实例
const xialuo = new Student('夏洛', 100)
console.log(xialuo.name)
console.log(xialuo.number)
xialuo.sayHi()
xialuo.eat()
// 实例
const wanglaoshi = new Teacher('王老师', '语文')
console.log(wanglaoshi.name)
console.log(wanglaoshi.major)
wanglaoshi.teach()
wanglaoshi.eat()
```

## 5-3 如何理解 JS 原型（隐式原型和显示原型）

**instanceof**

<img src="img/image-20201118093047772.png" alt="image-20201118093047772" style="zoom: 67%;" />

* instanceof 可以判断引用类型
* Object是所有class的父类

**原型**

<img src="img/image-20201118093401009.png" alt="image-20201118093401009" style="zoom:67%;" />

备注：`__proto__`隐式原型 `prototype`显示原型

![image-20201118093605969](img/image-20201118093605969.png)

<img src="img/image-20201118093706091.png" alt="image-20201118093706091" style="zoom:67%;" />

<img src="img/image-20201118093753630.png" alt="image-20201118093753630" style="zoom:67%;" />

<img src="img/image-20201118093832759.png" alt="image-20201118093832759" style="zoom:67%;" />

## 5-4 instanceof 是基于原型链实现的

<img src="img/image-20201118094231157.png" alt="image-20201118094231157" style="zoom: 67%;" />

<img src="img/image-20201118094238288.png" alt="image-20201118094238288" style="zoom: 80%;" />

![image-20201118094407188](img/image-20201118094407188.png)

![image-20201118094522021](img/image-20201118094522021.png)

**原型链**

那么`hasOwnPrototype`从哪里来？

<img src="img/image-20201118094609442.png" alt="image-20201118094609442" style="zoom:80%;" />

**再看Instanceof**

<img src="img/image-20201118095023644.png" alt="image-20201118095023644" style="zoom:80%;" />

**重要提示！！！**

* class是ES6语法规范，由ECMA委员会发布
* ECMA只规定语法规则，即我们代码的书写规范，不规定如何实现
* 以上实现方式都是v8引擎的实现方式，也是主流的

## 5-5 JS 原型相关面试题

### •  如何准确判断一个变量是不是数组

`a instance Array`

注意：结合原型链的本质理解

### • class的原型本质如何理解？

* 原型和原型链的图示
* 属性和方法的执行规则（沿着原型链搜索，一步一步往上寻找）

### • 手写一个简易的jQuery，考虑插件和扩展性

代码演示：

```js
class jQuery {
    constructor(selector) {
        const result = document.querySelectorAll(selector)
        const length = result.length
        for (let i = 0; i < length; i++) {
            this[i] = result[i]
        }
        this.length = length
        this.selector = selector
    }
    get(index) {
        return this[index]
    }
    each(fn) {
        for (let i = 0; i < this.length; i++) {
            const elem = this[i]
            fn(elem)
        }
    }
    on(type, fn) {
        return this.each(elem => {
            elem.addEventListener(type, fn, false)
        })
    }
    // 扩展很多 DOM API
}

// 插件机制
jQuery.prototype.dialog = function (info) {
    alert(info)
}

// “造轮子”（复写机制）
class myJQuery extends jQuery {
    constructor(selector) {
        super(selector)
    }
    // 扩展自己的方法
    addClass(className) {
    }
    style(data) {
    }
}

// const $p = new jQuery('p')
// $p.get(1)
// $p.each((elem) => console.log(elem.nodeName))
// $p.on('click', () => alert('clicked'))
```

**小结**

* class和继承，结合上面手写的jQuery的示例来理解
* instanceof
* 原型和原型链：图示 & 执行规则

# 第6章 JS基础-作用域和闭包

本章介绍作用域和闭包的知识点和题目。包括作用域，自由变量，闭包，this 等部分。作用域是“JS 三座大山”之二，不知道闭包的话，面试通过概率不大。

**知识点**

* 作用域和自由变量
* 闭包
* this

## 6-1 什么是作用域？什么是自由变量？

<img src="img/image-20201118112759528.png" alt="image-20201118112759528" style="zoom:80%;" />

<img src="img/image-20201118112928237.png" alt="image-20201118112928237" style="zoom:67%;" />

* 全局作用域

* 函数作用域

* 块级作用域

  ```js
  //ES6 块级作用域
  if(true){
  	let x = 100;
  }
  console.log(x);//会报错
  ```

<img src="img/image-20201118113046669.png" alt="image-20201118113046669" style="zoom:67%;" />

## 6-2 什么是闭包？闭包会用在哪里？

<img src="img/image-20201118113238970.png" alt="image-20201118113238970" style="zoom:80%;" />

<img src="img/image-20201118113300211.png" alt="image-20201118113300211" style="zoom:80%;" />

备注：两个打印的都是100

**总结：所有的自由变量的查找，是在函数定义的地方，向上级作用域查找！！！不是在执行的地方！！！！**

## 6-3 this 有几种赋值情况

> **this**
>
> * 作为普通函数
> * 使用call apply bind
> * 作为对象方法被调用
> * 在class方法中调用
> * 箭头函数
>
> 【总结】**this取什么值，是在函数执行的时候确定的！！！不是在函数定义的时候确定的！！！**(适用以上五种场景)

<img src="img/image-20201118114534997.png" alt="image-20201118114534997" style="zoom: 80%;" />

备注：这里使用call和bind改变了this指向，不同的是call会立刻执行，bind返回一个函数

<img src="img/image-20201118150027693.png" alt="image-20201118150027693" style="zoom: 80%;" />

这里注意：右边箭头函数里的this取值取得是箭头函数的值

<img src="img/image-20201118150522435.png" alt="image-20201118150522435" style="zoom:80%;" />

这里注意：this指的是当前创建的这个实例

## 6-4 作用域相关的面试题 

### • this的不同应用场景，如何取值

* 当作普通函数被调用
* 适用call apply bind
* 作为对象方法调用
* 在class的方法中调用
* 箭头函数

### • 手写bind函数

先举个例子演示一下bind如何使用？

```js
function fn1(a,b,c){
  console.log('this',this);
  console.log(a,b,c);
  return 'this is fn1'
}

const fn2 = fn1.bind({x:100},10,20,30)
const res = fn2();
console.log(res);
//this是{x:100}
//打印结果：
//10 20 30
// this is fn1
```

![image-20201118160421800](img/image-20201118160421800.png)

由上图可以看到bind是function的原型里的方法

**自己如何写一个bind？**

<img src="img/image-20201118160018102.png" alt="image-20201118160018102"  />

备注：

* 以上为我们模拟bind编写的函数

* aguments是个列表，但不是个数组，所以要用`Array.prototype.slice.call(arguments)`将其变为数组（这是一个很常用的方式）
* `shift()`获取数组中第一个元素
* `const self=this`是fn1.bind(...)中的fn1

### • 实际开发中闭包的应用场景，举例说明

> 写在前面:
>
> **闭包**是指有权访问另一个函数作用域中的变量的函数。**创建闭包**的常见方式，就是在一个函数内部创建另外一个函数
>
> 出自《js高程》

<img src="img/image-20201118161420794.png" alt="image-20201118161420794" style="zoom:67%;" />

```js
//闭包隐藏数据，只提供API
function createCache(){
  const data = {} //闭包中的数据，被隐藏，不被外界访问
  return {
    set:function(key,val){
      data[key] = val;
    },
    get:function(key){
      return data[key]
    }
  }
}

const c = createCache();
c.set('a',100);
console.log(c.get('a'));
```

### • 创建10个`<a>`,点击弹出序号

<img src="img/image-20201118162114706.png" alt="image-20201118162114706" style="zoom: 80%;" />

备注：

* 如果i在for外声明。即 let a ,i（全全局作用域），点击任何一个i都弹出10,因为当点击后执行alert的时候，i早都循环完了，都为10
* **let i放到for循环里面**，每次for循环执行的时候，都会形成一个新的块，alert(i)的i就在该块级作用域里面寻找

**小结**

* 作用域和自由变量
* 闭包：两种常见方式 & 自由变量查找规则
* this

# 第7章 JS基础-异步

本章介绍异步的知识点和题目。包括异步和同步的区别，异步应用场景，以及 Promise 。异步是“JS 三座大山”之三，所有公司的 JS 面试，100% 会考察异步和 Promise 。

**知识点**

* 单线程和异步
* 应用场景
* callback hell 和 Promise

## 7-1 同步和异步有何不同

**单线程和异步**

* JS是单线程语言，只能同时做一件事儿
* 浏览器和nodejs已支持JS启动**进程**，如Web Worker
* JS和DOM渲染共用同一个线程，因为JS可修改DOM结构
* 遇到等待（网络请求，定时任务）不能卡住，所以需要异步
* 异步基于回调callback函数形式

<img src="img/image-20201119195150472.png" alt="image-20201119195150472" style="zoom:67%;" />

> **异步和同步**
>
> * 基于JS是单线程语言
> * 异步不会阻塞代码执行
> * 同步会阻塞代码执行

## 7-2 异步的应用场景有哪些

**应用场景**

* 网络请求，如ajax请求、图片加载
* 定时任务，如setTimeout

<img src="img/image-20201119195641746.png" alt="image-20201119195641746" style="zoom: 67%;" />

<img src="img/image-20201119195712741.png" alt="image-20201119195712741" style="zoom:67%;" />

<img src="img/image-20201119195746886.png" alt="image-20201119195746886" style="zoom:67%;" />

## 7-3 promise的基本使用

【备注】：多层嵌套可能造成回调地狱，promise是异步编程的一种解决方案，可以使用then，catch来进行异步调用

![image-20201119195906470](img/image-20201119195906470.png)

**使用Promise异步请求数据示例**

![image-20201119200104952](img/image-20201119200104952.png)

![image-20201119200147274](img/image-20201119200147274.png)

## 7-4 JS 异步相关的面试题

### • 同步和异步的区别是什么？

* 基于JS是单线程语言
* 异步不会阻塞代码执行
* 同步会阻塞代码执行

### • 手写用Promise加载一张图片

```js
function loadImg(src) {
    const p = new Promise(
        (resolve, reject) => {
            const img = document.createElement('img')
            img.onload = () => {
                resolve(img)
            }
            img.onerror = () => {
                const err = new Error(`图片加载失败 ${src}`)
                reject(err)
            }
            img.src = src
        }
    )
    return p
}
```

测试例子：

```js
// const url = 'https://img.mukewang.com/5a9fc8070001a82402060220-140-140.jpg'
// loadImg(url).then(img => {
//     console.log(img.width)
//     return img
// }).then(img => {
//     console.log(img.height)
// }).catch(ex => console.error(ex))

const url1 = 'https://img.mukewang.com/5a9fc8070001a82402060220-140-140.jpg'
const url2 = 'https://img3.mukewang.com/5a9fc8070001a82402060220-100-100.jpg'

loadImg(url1).then(img1 => {
    console.log(img1.width)
    return img1 // 普通对象
}).then(img1 => {
    console.log(img1.height)
    return loadImg(url2) // promise 实例
}).then(img2 => {
    console.log(img2.width)
    return img2
}).then(img2 => {
    console.log(img2.height)
}).catch(ex => console.error(ex))

```

### • 前端使用异步的场景有哪些

* **网络请求**，如ajax请求
* **定时任务**，如setTimeout

### • setTimeout输出的问题

<img src="img/image-20201119201613640.png" alt="image-20201119201613640" style="zoom:67%;" />

答案：1 3 5 4(立刻打印) 2(1s后才打印)

**小结**

- 单线程和异步，异步和同步区别
- 前端异步的应用场景：网络请求 & 定时任务
- Promise 解决 callback hell

## 7-5 JS基础部分的考点总结

**内容**

* 变量的类型和计算
* 原型和原型链
* 作用域和闭包
* 异步和单线程

# 第8章 JS 异步进阶

JS 的特色就是异步编程，所有有很多关于异步的考点，本章都会讲解。如 event loop、promise、async-await、微任务和宏任务。学不会这些，就不算是精通 JS ，也无法进大厂。

## 8-1 本章考点介绍

**JS异步 - 进阶**

* 之前讲解JS异步，在于初阶的应用
* 本章在于JS异步的原理和进阶

**本章主要内容** 

* event loop
* promise进阶
* async/await
* 微任务/宏任务

## 8-2 看几个异步的面试题

<img src="img/image-20201119204234486.png" alt="image-20201119204234486" style="zoom:67%;" />

<img src="img/image-20201119204246141.png" alt="image-20201119204246141" style="zoom: 80%;" />

<img src="img/image-20201119204422629.png" alt="image-20201119204422629" style="zoom:80%;" />

<img src="img/image-20201119204529963.png" alt="image-20201119204529963" style="zoom:80%;" />

<img src="img/image-20201119204602033.png" alt="image-20201119204602033" style="zoom:80%;" />

## 8-3 什么是event loop

**event loop（事件循环/事件轮询）**

* JS是单线程运行的
* 异步是基于回调来实现
* event loop就是异步回调的实现原理

**JS如何执行？**

* 从前到后，一行一行执行
* 如果某一行执行报错，则停止下面代码的执行
* 先把同步代码执行完，再执行异步

**示例：**

```js
console.log('Hi');

setTimeout(function cb1(){
  console.log('cb1');//cb 即callback
},5000)

console.log('bye');
//打印出：Hi bye cb1
```

**开始讲解event loop过程**

* 难理解
* 尽量深入浅出
* 不要扣细节，不要扩大范围，核心是event loop的过程

## 8-4 event loop 的执行过程

**再看一遍示例**

```js
console.log('Hi');

setTimeout(function cb1(){
  console.log('cb1');//cb 即callback
},5000)

console.log('bye');
//打印出：Hi bye cb1
```

![image-20201120094319991](img/image-20201120094319991.png)

![image-20201120094512711](img/image-20201120094512711.png)

![image-20201120094537600](img/image-20201120094537600.png)

> **总结event loop过程**
>
> * 同步代码，一行一行放在Call Stack执行
> * 遇到异步，会先“记录”下，等待时机（定时任务，网络请求等）
> * 时机到了，就移动到Callback Queue
> * 如 Call Stack为空（即同步代码执行完）Event Loop开始工作
> * 轮询查找Callback Queue，如有则移动到Call Stack执行
> * 然后继续轮询查找（永动机一样）

## 8-5 DOM事件和event loop的关系

<img src="img/image-20201120095420595.png" alt="image-20201120095420595" style="zoom:80%;" />

![image-20201120095758023](img/image-20201120095758023.png)

**DOM事件和event loop**

* JS是单线程的
* 异步（setTimeout，ajax等）使用回调，基于event loop
* DOM事件也使用回调，基于event loop

## 8-6 Promise有哪三种状态

### • Promise 哪几种状态，如何变化？

**Promise进阶**

*  三种状态
* 状态的表现和变化
* then和catch对状态的影响

**三种状态**

* pending resolved rejected
* pending --> resolved 或 pending -->rejected
* 变化不可逆

**代码演示 - 状态变化**

![image-20201120101635774](img/image-20201120101635774.png)

![image-20201120101740043](img/image-20201120101740043.png)

![image-20201120101834408](img/image-20201120101834408.png)

![image-20201120101850579](img/image-20201120101850579.png)

**状态的表现**

* pending状态，不会触发then和catch
* resolved状态，会触发后续的then回调函数
* rejected状态，会触发后续的catch回调函数

**代码演示 - 状态表现**

```js
const p1 = Promise.resolve(100); //resolved
//console.log('p1',p1);
p1.then(data => {
  console.log('data1',data);
}).catch(err =>{
  console.log('err1',err);
})

const p2 = Promise.reject('err') //rejected
//console.log('p2',p2);
p2.then(data => {
  console.log('data2',data);
}).catch(err =>{
  console.log('err2',err);
})
```

打印：

```
data1 100
err2 err
```

## 8-7 Promise的then和catch如何影响状态的变化

**then和catch改变状态**

* then 正常返回resolved，里面有报错则返回rejected
* catch正常返回resolved，里面有报错则返回rejected

**代码：then影响Promise状态**

```js
const p1 = Promise.resolve().then(()=>{
  return 100
})
//console.log('p1',p1);//resolved 会触发后续then回调
p1.then(()=>{
  console.log('123');
})


const p2 = Promise.resolve().then(()=>{
  throw new Error('then error')
})
//console.log('p2',p2);//rejected 会触发后续catch回调
p2.then(()=>{
  console.log('456');
}).catch(err =>{
  console.log('err100',err);
})
```

打印

```
123
err100 Error:then error
```

**代码2：catch影响Promise状态**

```js
const p3 = Promise.reject('my err').catch(err =>{
  console.log(err);
})
//console.log('p3',p3);//注意 是resolved！触发then回调！
p3.then(()=>{
  console.log(100);
})

const p4 = Promise.reject('my err').catch(err =>{
  throw new Error('catch console.error();')
})
//console.log('p4',p4);//是rejected状态的Promise ！触发catch回调
p4.then(()=>{
  console.log(200);
}).catch(()=>{
  console.log('some error');
}) 

```

打印

```
my err
100
some error
```

## 8-8 Promise关于then和catch的面试题

### • 场景题：Promise的then和catch的连接

<img src="img/image-20201119204246141.png" alt="image-20201119204246141" style="zoom: 80%;" />

```js
// 第一题
Promise.resolve().then(() => {
    console.log(1)
}).catch(() => {
    console.log(2)
}).then(() => {
    console.log(3)
})
// 1 3
```

```js
// 第二题
Promise.resolve().then(() => {
    console.log(1)
    throw new Error('erro1')
}).catch(() => {
    console.log(2)
}).then(() => {
    console.log(3)
})
// 1 2 3
```

```js
// 第三题
Promise.resolve().then(() => {
    console.log(1)
    throw new Error('erro1')
}).catch(() => {
    console.log(2)
}).catch(() => { // 注意这里是 catch
    console.log(3)
})
// 1 2
```

**Promise总结**

* 三种状态，状态的变现和变化
* then和catch对状态的影响（重要）
* then和catch的链式调用（常考）

## 8-9 async-await语法介绍

**async/await**

* 异步回调 callback hell
* Promise then catch链式调用，但也是基于回调函数
* **async/await是同步语法，彻底消灭了回调函数**（备注：**async/await用同步的方式来编写异步代码**，不用再写回调函数）

代码演示

```js
function loadImg(src) {
    const promise = new Promise((resolve, reject) => {
        const img = document.createElement('img')
        img.onload = () => {
            resolve(img)
        }
        img.onerror = () => {
            reject(new Error(`图片加载失败 ${src}`))
        }
        img.src = src
    })
    return promise
}

async function loadImg1() {
    const src1 = 'http://www.imooc.com/static/img/index/logo_new.png'
    const img1 = await loadImg(src1)
    return img1
}

async function loadImg2() {
    const src2 = 'https://avatars3.githubusercontent.com/u/9583120'
    const img2 = await loadImg(src2)
    return img2
}

(async function () {
    // 注意：await 必须放在 async 函数中，否则会报错
    try {
        // 加载第一张图片
        const img1 = await loadImg1()
        console.log(img1)
        // 加载第二张图片
        const img2 = await loadImg2()
        console.log(img2)
    } catch (ex) {
        console.error(ex)
    }
})()
```

## 8-10 async-await和Promise有什么关系

 **async-await和Promise有什么关系**

* async/wait是消灭异步回调的终极武器
* 但async/wait和Promise并不互斥
* 反而，async/wait和Promise两者相辅相成

<img src="img/image-20201120113314028.png" alt="image-20201120113314028" style="zoom:67%;" />

**代码演示**

* async 函数返回结果都是 Promise 对象（如果函数内没返回 Promise ，则自动封装一下）

  ```js
  async function fn1(){
    return 100;
    //return Promise.resolve(100)
  }
  
  const res1 = fn1();//执行async函数，返回的是一个Promise对象
  console.log('res1',res1);//Promise对象
  
  res1.then(data => {
    console.log('data',data);//100
  })
  ```

  ![image-20201120112342874](img/image-20201120112342874.png)

* await 后面跟 Promise 对象：会阻断后续代码，等待状态变为 resolved ，才获取结果并继续执行

  await 后续跟非 Promise 对象：会直接返回

  ```js
  (async function(){
    const p1 = Promise.resolve(300)
    const data = await p1;//await 相当于 Promise then
    console.log('data',data);//打印：data 300
  })();
  
  (async function(){
    const data1 = await 400;//await 后面不是promise，也会自动封装；相当于 await Promise.resolve(400)
    console.log('data1',data1);//打印：data1 400
  })();
  
  
  async function fn1(){
    return 200;
  }
  (async function(){
    const data2 = await fn1();
    console.log('data2',data2);//打印：data2 200
  })();
  ```

  【注意】一个小的点

  ```js
  !(async function(){
    const p4 = Promise.reject('err4');//rejected状态
    const res = await p4;//会报错，await相当于then，但这里是rejected状态，所以不会去执行
    console.log(res);
  })();
  ```

* try...catch捕获rejected状态

  ```js
  !(async function(){
    const p4 = Promise.reject('err4');//rejected状态
    try{
      const res = await p4;
      console.log(res);
    }catch(ex){
      console.log(ex);//try..catch相当于promise catch
    }
  })();
  
  //打印：err4
  ```

>  总结来看
>
> * async 封装 Promise
> * await 处理 Promise 成功
> * try...catch 处理 Promise 失败

## 8-11 async-await是语法糖，异步的本质还是回调函数

**异步的本质**

* async/await是消灭异步回调的终极武器
* JS还是单线程，还得是有异步，还得是基于event loop
* async/await只是一个语法糖，但这颗糖真香！

> await是同步写法，但本质还是异步调用

**代码演示1**

```js
async function async1 () {
  console.log('async1 start')//2 
  await async2() 
  //await的后面，都可以看作是callback里的内容，即异步
    //类似event loop setTimeout(cb1)
  console.log('async1 end') // 关键在这一步，它相当于放在 callback 中，最后执行
}

async function async2 () {
  console.log('async2')//3
}

console.log('script start')//1
async1()
console.log('script end')//4
//同步代码已经执行完(event loop)
```

> 即，只要遇到了`await`，后面的代码都相当于放在callback里

打印顺序：

1. script start
2. async1 start
3.  async2
4. script end
5. async1 end

**代码演示2**

```js
async function async1 () {
  console.log('async1 start')//2
  await async2() 
  
  //下面三行都是异步回调 callback的内容
  console.log('async1 end') //5
  await async3();

    //下面一行是异步回调的内容
    console.log('async1 end 2');//7
}

async function async2 () {
  console.log('async2')//3
}

async function async3 () {
  console.log('async3') //6
}

console.log('script start')//1
async1()
console.log('script end')//4
//同步代码执行完 event loop
```

输出：

1. script start
2. async1 start
3. async2
4. script end
5. async1 end
6. async3
7. async1 end 2

## 8-12 for-of的应用场景

**for...of**

* `for...in`（以及`forEach for`）是常规的同步遍历
* `for...of`常用于**异步的遍历**

**代码演示**

```js
function muti(num){
  return new Promise(resolve => {
    setTimeout(()=>{
      resolve(num*num)
    },1000)
  })
}

const nums = [1,2,3]

//同步遍历
// nums.forEach(async (i)=>{
//   const res = await muti(i);
//   console.log(res);
// })
// //1s后同时打印出1 4 9 

//异步遍历
!(async function(){
  for(let i of nums){
    const res = await muti(i);
    console.log(res);
  }
})();
//每隔1s 依次打印出1 4 9
//（先执行第一个，第一个有结果后再执行第二个。。。。（依次执行））
```

**async/await总结**

* async/await解决了异步回调，是一个很香的语法糖
* async/await和Promise的关系，重要！！！
* for...of的使用

## 8-13 什么是宏任务和微任务

**宏任务 `macroTask` 和微任务 `microTask`**

* 什么是宏任务，什么是微任务
* event loop 和DOM渲染
* 微任务和宏任务的区别

**代码**

```js
console.log(100)
setTimeout(() => {
    console.log(200)
})
Promise.resolve().then(() => {
    console.log(300)
})
console.log(400)
// 100 400 300 200
```

### • 宏任务和微任务的区别

<img src="img/image-20201120153909012.png" alt="image-20201120153909012" style="zoom: 67%;" />

【备注】以上宏任务和微任务其实就是前端所有的异步的情况

## 8-14 event-loop和DOM渲染的关系

**event loop和DOM渲染**

* 再次复习一边event loop的过程
* JS是单线程的，而且和DOM渲染共用一个线程
* JS执行的时候，得留一些时机供DOM渲染

<img src="img/image-20201120154220294.png" alt="image-20201120154220294" style="zoom:67%;" />

**回顾event loop过程（增加DOM渲染时机）**

![image-20201120155616902](img/image-20201120155616902.png)

![image-20201120155633337](img/image-20201120155633337.png)

## 8-15 为什么微任务比宏任务执行更早

**event loop和DOM渲染**

* 每次Call Stack清空（即每次轮询结束），即同步任务执行完
* 都是DOM重新渲染的机会，DOM结构如有改变则重新渲染
* 然后再去触发下一次Event Loop

**代码演示**

```js
const $p1 = $('<p>一段文字</p>')
const $p2 = $('<p>一段文字</p>')
const $p3 = $('<p>一段文字</p>')
$('#container')
            .append($p1)
            .append($p2)
            .append($p3)

console.log('length',  $('#container').children().length )
alert('本次 call stack 结束，DOM 结构已更新，但尚未触发渲染')
//(alert会阻断js执行，也会阻断DOM渲染，便于查看效果)
```

<img src="img/image-20201120160911954.png" alt="image-20201120160911954" style="zoom:80%;" />

点击“确定”之后

<img src="img/image-20201120161006898.png" alt="image-20201120161006898" style="zoom:80%;" />

**微任务和宏任务的区别**

* **宏任务：**DOM渲染**后**触发，如setTimeout
* **微任务：**DOM渲染**前**触发，如Promise
* 下面先演示现象，稍后追究原理

**代码演示**

```js
// 修改 DOM
const $p1 = $('<p>一段文字</p>')
const $p2 = $('<p>一段文字</p>')
const $p3 = $('<p>一段文字</p>')
$('#container')
    .append($p1)
    .append($p2)
    .append($p3)

// 微任务：渲染之前执行（DOM 结构已更新）
 Promise.resolve().then(() => {
     const length = $('#container').children().length
     alert(`micro task ${length}`)
})

// 宏任务：渲染之后执行（DOM 结构已更新）
setTimeout(() => {
    const length = $('#container').children().length
    alert(`macro task ${length}`)
})
```

![image-20201120214904204](img/image-20201120214904204.png)

点击确定后

![image-20201120214938554](img/image-20201120214938554.png)

## 8-16 微任务和宏任务的根本区别

**从event loop解释，为何微任务执行更早？**

![image-20201120161859667](img/image-20201120161859667.png)

![image-20201120161921664](img/image-20201120161921664.png)

可以看到setTimeout的执行是在DOM之后

如果是遇到Promise，会等待时机放到 micro task queue

![image-20201120162027312](img/image-20201120162027312.png)

**为什么有这样的区别？**

* **微任务**是**ES6**语法规定的
* **宏任务**是由**浏览器**规定的

所以，**callStack清空后，先执行微任务，在尝试DOM渲染，再触发event loop(执行宏任务)**

![image-20201120162145118](img/image-20201120162145118.png)

**微任务和宏任务 - 总结**

* 宏任务有哪些？微任务有哪些？微任务触发时机更早
* 微任务，宏任务和DOM渲染的关系
* 微任务，宏任务和DOM渲染，在event loop的过程

## 8-17 解答JS异步的面试题

### • 描述 event loop 运行机制（可画图）

* 自行回顾event loop的过程
* 和DOM渲染的关系
* 微任务和宏任务在event loop过程中的不同处理

### • 场景题：async/await语法

![image-20201120164939928](img/image-20201120164939928.png)

打印：

```
a 是个promise
b 是100

start
100
200
error //c reject会直接报错
```

 • 场景题：各类异步执行顺序问题

![image-20201120165231345](img/image-20201120165231345.png)

```js
async function async1(){
  console.log('async1 start');//2
  await async2();

  //await后面的都作为回调内容 —— 微任务
  console.log('async1 end');//6
}

async function async2(){
  console.log('async2');//3
}

console.log('script start');//1 

setTimeout(function(){ //宏任务 setTimeout
  console.log('setTimeout');//8
},0)

async1() 

//初始化Promise时，传入的函数会立刻被执行
new Promise (function(resolve){
  console.log('Promise1');//4 
  resolve()
}).then(function(){ //then是异步 —— 微任务
  console.log('Promise2');//7
})

console.log('script emd');//5

```

打印出：

```
script start
async1 start
async2
Promise1
script emd
async1 end
Promise2
setTimeout
```

【解释】

* 第5步之后 同步代码执行完毕(event loop里的call stack被清空)。
* 接下来执行微任务，按照顺序来说，微任务先执行async1 end，再执行promise2
* 执行微任务之后尝试触发DOM渲染（本例子没有DOM渲染）
* 然后触发event loop，执行宏任务，即setTimeout

## 8-18 本章考点总结

**JS异步进阶 - 总结**

* event loop
* promise进阶
* async/await
* 微任务/宏任务

**event loop过程**

* 同步代码，一行一行放在Call Stack执行
* 遇到异步，会先“记录”下，等待时机（定时，网络请求等）
* 时机到了，就移动到Callback Queue
* 如 Call Stack为空（即同步代码执行完）Event Loop开始工作
* 轮询查找Callback Queue，如有则移动到Call Stack执行
* 然后继续轮询查找（永动机一样）

**DOM事件和event loop**

* JS是单线程的
* 异步（setTimeout，ajax等）使用回调，基于event loop
* DOM事件也使用回调，基于event loop

**Promise进阶**

*  三种状态
* 状态的表现和变化
* then和catch对状态的影响

**async/await总结**

* async/await解决了异步回调，是一个很香的语法糖
* async/await和Promise的关系，重要！！！
* for...of的使用

**微任务和宏任务 - 总结**

* 宏任务有哪些？微任务有哪些？微任务触发时机更早
* 微任务，宏任务和DOM渲染的关系
* 微任务，宏任务和DOM渲染，在event loop的过程

# 第9章 JS-Web-API-DOM

本章介绍 DOM 操作的知识点和题目。包括 DOM 结构，常用 DOM 操作，DOM 性能优化等。DOM 是网页结构的基础，学会 DOM 操作才可以做网页开发。

## 9-1 从JS基础到JS-Web-API

**从JS基础到JS-Web-API**

* JS基础语法，规定语法（ECMA 262标准）
* JS Web API，网页操作的API（w3c标准）
* 前者是后者的基础，两者结合才能真正实际应用

**JS Web API有哪些内容?**

* DOM
* BOM
* 事件绑定
* ajax
* 存储

## 9-2 DOM的本质是什么

**前言**

* vue和React框架应用广泛，封装了DOM(Document object Model)操作
* 但DOM操作一直都会是前端工程师的基础，必备知识
* 只会vue而不懂DOM操作的前端程序员，不会长久

**知识点**

* DOM本质
* DOM节点操作
* DOM结构操作
* DOM性能

**DOM本质**

![image-20201125104205025](img/image-20201125104205025.png)

![image-20201125104223532](img/image-20201125104223532.png)

> DOM的本质是从HTML文件解析出来的一棵树

![image-20201125104339485](img/image-20201125104339485.png)



## 9-3 DOM节点操作

**DOM节点操作**

* 获取DOM节点
* attribute
* property

**获取DOM节点**

![image-20201125104558216](img/image-20201125104558216.png)

```html
 <body>
        <div id="div1" class="container">
            <p id="p1">一段文字 1</p>
            <p>一段文字 2</p>
            <p>一段文字 3</p>
        </div>
        <div id="div2" class="container">
            <img src="https://img3.mukewang.com/5a9fc8070001a82402060220-100-100.jpg"/>
        </div>
    </body>
```

```js
//通过id  getElementById
console.log("通过id ");
const div1 = document.getElementById('div1')
console.log('div1', div1)

//通过标签名 getElementsByTagName(集合)
console.log("通过标签名");
const divList = document.getElementsByTagName('div') // 集合
console.log('divList.length', divList.length)
console.log('divList[1]', divList[1])

//通过类名 getElementsByClassName(集合)
console.log("通过类名");
const containerList = document.getElementsByClassName('container') // 集合
console.log('containerList.length', containerList.length)
console.log('containerList[1]', containerList[1])

//通过css选择器 querySelectorAll(集合)
console.log("通过css选择器");
const pList = document.querySelectorAll('p')
console.log('pList', pList)
```

![image-20201125105430736](img/image-20201125105430736.png)



**DOM节点的property**

<img src="img/image-20201125105451450.png" alt="image-20201125105451450" style="zoom: 80%;" />

```html
<head>
        <style>
            .container {
                border: 1px solid #ccc;
            }
            .red {
                color: red;
            }
        </style>
    </head>
    <body>
        <div id="div1" class="container">
            <p id="p1">一段文字 1</p>
            <p>一段文字 2</p>
            <p>一段文字 3</p>
        </div>
    </body>
```

```js
// property 形式
//可以设置属性
p1.style.width = '100px'
//获取属性
console.log( p1.style.width ) //100px
p1.className = 'red'
console.log( p1.className ) //red
console.log(p1.nodeName) //p
console.log(p1.nodeType) // 1
```

![image-20201125105954277](img/image-20201125105954277.png)

> property这种形式是通过修改或获取js的属性的方式来改变CSS样式/页面渲染结构

**DOM节点的attribute**

<img src="img/image-20201125110217838.png" alt="image-20201125110217838" style="zoom:80%;" />

```js
const pList = document.querySelectorAll('p')
const p1 = pList[0]

// attribute
p1.setAttribute('data-name', 'imooc')
console.log( p1.getAttribute('data-name') )
p1.setAttribute('style', 'font-size: 50px;')
console.log( p1.getAttribute('style') )
```

![image-20201125110448353](img/image-20201125110448353.png)

> attribute通过`getAttribute`和`setAttribute`的形式来修改HTML结构

> 总结：
>
> **property和attribute**
>
> * property：修改对象属性，不会体现到HTML机构中
> * attribute：修改html属性，会改变html结构
> * 两者都有可能引起DOM重新渲染

## 9-4 DOM结构操作

**DOM结构操作**

* 新增/插入节点
* 获取子元素列表，获取父元素
* 删除子元素

**新增/插入节点**

<img src="img/image-20201125110851700.png" alt="image-20201125110851700" style="zoom:80%;" />

```html
<body>
        <div id="div1" class="container">
            <p id="p1">一段文字 1</p>
            <p>一段文字 2</p>
            <p>一段文字 3</p>
        </div>
        <div id="div2" class="container">
            <img src="https://img3.mukewang.com/5a9fc8070001a82402060220-100-100.jpg"/>
        </div>   
  </body>
```

```js
const div1 = document.getElementById('div1')
const div2 = document.getElementById('div2')
// 新建节点
const newP = document.createElement('p')
newP.innerHTML = 'this is newP'
// 插入节点
div1.appendChild(newP)

// 移动节点
const p1 = document.getElementById('p1')
div2.appendChild(p1)
```

![image-20201125111604940](img/image-20201125111604940.png)

**获取子元素列表，获取父元素**

<img src="img/image-20201125111615253.png" alt="image-20201125111615253" style="zoom:80%;" />

```js
const div1 = document.getElementById('div1')
const div2 = document.getElementById('div2')

// 获取父元素
console.log( p1.parentNode )

// 获取子元素列表
const div1ChildNodes = div1.childNodes
console.log( div1.childNodes);//注意这里在p中间有text
const div1ChildNodesP = Array.prototype.slice.call(div1.childNodes).filter(child => {
    if (child.nodeType === 1) {
        return true
    }
    return false
})
console.log('div1ChildNodesP', div1ChildNodesP)
```

备注：

* 使用`Array.prototype.slice.call(div1.childNodes)`将其变为数组
* 使用`filter`排除掉那些text	

![image-20201125112400184](img/image-20201125112400184.png)

**删除节点**

<img src="img/image-20201125112454782.png" alt="image-20201125112454782" style="zoom:80%;" />

```js
div1.removeChild( div1ChildNodesP[0] )
```

## 9-5 如何优化 DOM 操作的性能

**DOM性能**

* DOM操作非常“昂贵”，所以要避免频繁的DOM操作
* 可以对DOM查询做缓存
* 将频繁操作改为一次性操作

<img src="img/image-20201125112717431.png" alt="image-20201125112717431"  />

![image-20201125112825957](img/image-20201125112825957.png)

```html
    <body>
        <ul id="list">
        </ul>
        <script src="./dom-3.js"></script>
    </body>
```

```js
const list = document.getElementById('list')

// 创建一个文档片段，此时还没有插入到 DOM 结构中
const frag = document.createDocumentFragment()

for (let i  = 0; i < 20; i++) {
    const li = document.createElement('li')
    li.innerHTML = `List item ${i}`

    // 先插入文档片段中
    frag.appendChild(li)
}

// 都完成之后，再统一插入到 DOM 结构中
list.appendChild(frag)

console.log(list)
```

## 9-6 DOM 操作相关的面试题

### • DOM是哪种数据结构

* 树（DOM树）



### • DOM操作常用API

| API             |                                                             |            |
| --------------- | ----------------------------------------------------------- | ---------- |
| **DOM节点操作** |                                                             |            |
| 1. 获取DOM元素  | `getElementById`                                            | 获取单元素 |
|                 | `getElementsByTagName`                                      | 获取集合   |
|                 | `getElementsByClassName`                                    | 获取集合   |
|                 | `querySelectorAll`                                          | 获取集合   |
| 2 property      | `p.style.width = 100`                                       | 修改样式   |
|                 | `p.className = 'p1'`                                        | 修改class  |
|                 | `p.nodeName`                                                |            |
|                 | `p.nodeType`                                                | 1          |
| 3. attribute    | `p.getAttribute('style')`                                   |            |
|                 | `p.setAttribute('data-name','imooc)`                        |            |
| **DOM结构操作** |                                                             |            |
| 1.新增/插入节点 | `docuemnt.createElement('p')`                               |            |
|                 | `div1.appendChild(p1)`                                      |            |
| 2 获取父元素    | `div1.parentNode`                                           |            |
| 3 获取子元素    | `div1.childodes`                                            |            |
| 4 删除节点      | `const child  = div1.childNodes;div1.removeChild(child[0])` |            |

### • attr和property的区别

* property：修改对象属性，不会体现到HTML机构中
* attribute：修改html属性，会改变html结构
* 两者都有可能引起DOM重新渲染
* 尽量使用property

### • 一次性插入多个DOM节点，考虑性能

* 通过fragment来做
* 考虑DOM节点的缓存

# 第10章 JS-Web-API-BOM

## 10-1 BOM 操作相关的面试题

**知识点**

* navigator
* screen
* location
* history

![image-20201125151212073](img/image-20201125151212073.png)

![image-20201125151359545](img/image-20201125151359545.png)



### •  如何识别浏览器的类型

```js
const ua = navigator.userAgent
const isChrome = ua.indexOf('Chorme')
console.log(isChorme)
```

### •  分析拆解url各个部分

```js
//例子 https://coding.imooc.com/class/evaluation/415.html?user=abc#Anchor
location.href
"https://coding.imooc.com/class/evaluation/415.html?user=abc#Anchor"
location.protocol
"https:"
location.pathname
"/class/evaluation/415.html"
location.search
"?user=abc"
location.hash
"#Anchor
```

# 第11章 JS-Web-API-事件

本章介绍事件绑定的知识点和题目。包括事件绑定，事件冒泡机制，事件代理。事件能让网页和鼠标、键盘进行交互，初级 JS 面试必考。

## 11-1 事件绑定和事件冒泡

**事件绑定**

![image-20201125153517345](img/image-20201125153517345.png)

![image-20201125153542130](img/image-20201125153542130.png)

代码演示：

```html
<body>
        <button id="btn1">一个按钮</button>
        <script src="./event.js"></script>
    </body>
```

```js
//通用的事件绑定函数
function bindEvent(elem,type,fn){
  elem.addEventListener(type,fn)
}

const btn1 = document.getElementById('btn1')
bindEvent(btn1,'click',event =>{
  //console.log(event.target);//获取触发的元素：<button id="btn1">一个按钮</button> 
  event.preventDefault();//阻止默认行为
  alert('clicked')
})
```

**事件冒泡**

![image-20201125154324506](img/image-20201125154324506.png)

会先打印 激活，再打印 取消

## 11-2 什么是事件代理

![image-20201125161722585](img/image-20201125161722585.png)

```html
<body>
        <div id="div3">
            <a href="#">a1</a><br>
            <a href="#">a2</a><br>
            <a href="#">a3</a><br>
            <a href="#">a4</a><br>
        </div>
        <script src="./event.js"></script>
    </body>
```

```js
function bindEvent(elem,type,fn){
  elem.addEventListener(type,fn)
}

// 代理绑定（只在父元素上挂载事件，适用于瀑布流，结构复杂不适合每一个都绑定的情况下）
const div3 = document.getElementById('div3')
bindEvent(div3, 'click', event => {
  event.preventDefault()
  const target = event.target;
  if(target.nodeName === 'A'){
    alert(target.innerHTML)
  }
})
```

**事件代理**

* 代码简洁
* 减少浏览器内存占用
* 但是，不要滥用



## 11-3 DOM 事件相关的面试题

### • 编写一个通用的事件监听函数

**通用的事件绑定函数**

包含普通绑定和代理绑定

```js
//通用的事件绑定函数
function bindEvent(elem,type,selector,fn){
  if(fn == null){//传了三个函数
    fn = selector;
    selector = null;
  }
  elem.addEventListener(type,event=>{
    const target = event.target;
    if(selector){
      //代理绑定
      if(target.matches(selector)){
        fn.call(target,event)
      }
    }else{
      //普通绑定
      fn.call(target,event)
    }
  })
}
```

备注：如果元素被指定的选择器字符串选择，**`Element.matches()`** 方法返回true; 否则返回false。https://developer.mozilla.org/zh-CN/docs/Web/API/Element/matches

测试

```html
<body>
        <button id="btn1">一个按钮</button>

        <div id="div3">
            <a href="#">a1</a><br>
            <a href="#">a2</a><br>
            <a href="#">a3</a><br>
            <a href="#">a4</a><br>
            <button>加载更多...</button>
        </div>
        <script src="./event.js"></script>
    </body>
```

```js
// 普通绑定
const btn1 = document.getElementById('btn1')
bindEvent(btn1, 'click', function(event) {
  event.preventDefault()//这里不能用this是因为this必须是当前触发的元素(注意不能使用箭头函数！！那样this指的是上层作用域即window)
  alert(this.innerHTML)
})

// 代理绑定
const div3 = document.getElementById('div3')
bindEvent(div3, 'click', 'a', function(event) {
  event.preventDefault()
  alert(this.innerHTML)//this必须是当前触发的元素
})
```

![image-20201125164553714](img/image-20201125164553714.png)

![image-20201125164614980](img/image-20201125164614980.png)



### • 描述事件冒泡的流程

* 基于DOM树形结构
* 事件会顺着触发元素向上冒泡
* 应用场景：代理

### • 下拉的图片列表，如何监听每个图片的点击？

* 事件代理
* 用`e.target`获取触发元素
* 用`matches`来判断是否是触发元素

# 第12章 JS-Web-API-Ajax

本章介绍 ajax 相关的知识点和题目。包括 XMLHttpRequest ，同源策略，跨域方式，以及常用插件介绍。我们早就进入了动态网页时代，而当下的前后端分离开发方式，更加要求每个工程师必须熟练掌握 ajax 。

【备注】：

* 本章学习要使用MAMP开启服务
* 打开MAMP后，E:\softwareInstall\MAMP\htdocs是工作目录的默认路径
* 访问http://localhost/ajax-learn/ajax.html即可

**知识点**

* XMLHttpRequest
* 状态码
* 跨域：同源策略，跨域解决方案






## 12-1 ajax 的核心API -XMLHttpRequest

**Get请求**

```js
//get请求
const xhr = new XMLHttpRequest;
xhr.open('GET','./data/test.json',true)
xhr.onreadystatechange = function(){
  //这里的函数异步执行，可参考之前JS基础中的异步模块 true代表异步
  if(xhr.readyState === 4){
    if(xhr.status === 200){
      console.log(JSON.parse(xhr.responseText));
      alert(xhr.responseText)
    }else{
      console.log('其他出错情况');
    }
  }
}
xhr.send(null)
```

**Post请求**

```js
const xhr = new XMLHttpRequest;
xhr.open('POST','./login',true)
xhr.onreadystatechange = function(){
  if(xhr.readyState === 4){
    if(xhr.status === 200){
      alert(xhr.responseText)
    }else{
      console.log('其他出错情况');
    }
  }
}

const postData = {
  userName:'sxc',
  password:'123'
}
xhr.send(JSON.stringify(postData));//发送的是字符串注意
```

![image-20201125172333564](img/image-20201125172333564.png)

![image-20201125172559953](img/image-20201125172559953.png)

【备注】：301 永久重定向 302 临时重定向 304 资源未改变（服务器没有返回新的资源，浏览器用自己的缓存资源）

##  12-2 什么是浏览器的同源策略

**跨域**

* 什么是跨域（同源策略）
* JSONP
* CORS（服务端支持）

**同源策略**

* ajax请求时，出于安全考虑，浏览器要求当前网页和server必须同源
* 同源：协议，域名，端口，三者必须一致
* 例如：前端：http://a.com:8080/ server:https://b.com/api/xx 这三个就完全不一样

> **加载图片 css js可无视同源策略**
>
> * `<img src=跨域的图片地址>`
> * `<link href=跨域的CSS地址>`
> * `<script src=跨域的js地址></script>`
> * `<img/>`可用于统计打点，可使用第三方统计服务
> * `<link/><scirpt>`可使用CDN，CDN一般都是外域
> * `<script>`可实现JSONP
>
> **跨域**
>
> * 所有的跨域，都必须经过server端允许和配合
> * 未经server端允许就实现跨域，说明浏览器有漏洞，危险信息

## 12-3 实现跨域的常见方式 - jsonp 和 CORS

> **JSONP**
>
> * 访问`https://imooc.com`，服务端一定返回一个html文件吗？
> * 答：服务器可以任意动态拼接数据返回，只要符号html格式要求
> * 同理于`<script src="https://imooc.com/getData.js">`
> * `<script>`可绕过跨域限制
> * 服务器可以任意动态拼接数据返回
> * 所以，`<script>`就可以获得跨域的数据，只要服务端愿意返回

![image-20201126093747150](img/image-20201126093747150.png)

<img src="img/image-20201126094111098.png" alt="image-20201126094111098" style="zoom:80%;" />

> **CORS（http控制访问）**
>
> * 默认情况下，XHR对象只能访问与包含它的页面位于同一个域中的资源（备注：也就是同源限制：必须要相同的协议，域，端口才能访问）
>
> * **CROS定义了在必须访问跨域资源时，浏览器与服务器应该如何沟通。**
>
> * CROS背后的思想：使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。
>
>   ![](img/image-20201104160651709.png)



![image-20201126094319398](img/image-20201126094319398.png)

## 12-4 ajax 相关的面试题 

### • 手写一个简易的ajax

**基础版本**

```js
function ajax(url,successFn){
    const xhr = new XMLHttpRequest()
    xhr.open("GET",url,true)
    xhr.onreadystatechange = function(){
        if(xhr.readyState === 4){
            if(xhr.status === 200){
                successFn(xhr.responseText)
            }
        }
    }
    xhr.send(null)
}
```

**更好的版本（使用Promise封装Ajax操作）**

```js  
function ajax(url){
  const p = new Promise((resolve,reject)=>{
    const xhr = new XMLHttpRequest()
    xhr.open('GET',url,true)
    xhr.onreadystatechange = function(){
      if(xhr.readyState === 4){
        if(xhr.status === 200){
          resolve(
            JSON.parse(xhr.responseText)
          )
        }else if(xhr.status === 404){
          reject(new Error('404 not found'))
        }
      }
    }
    xhr.send(null)
  })
  return p
}

const url = './data/test.json';
ajax(url)
.then(res => console.log(res))
.catch(err => console.log(err))
```

<img src="img/image-20201126164928130.png" alt="image-20201126164928130" style="zoom:67%;" />

### • 跨域的常用实现方式

* JSONP
* CROS



**知识点**

* XMLHttpRequest
* 状态码：readyState status
* 跨域：同源策略（如何绕过），JSONP，CORS

## 12-5 实际项目中 ajax 的常用插件

**1. JQuery**

```js
    $(function(){
        //请求参数
        var list = {};
        //
        $.ajax({
            //请求方式
            type : "POST",
            //请求的媒体类型
            contentType: "application/json;charset=UTF-8",
            //请求地址
            url : "http://127.0.0.1/admin/list/",
            //数据，json字符串
            data : JSON.stringify(list),
            //请求成功
            success : function(result) {
                console.log(result);
            },
            //请求失败，包含具体的错误信息
            error : function(e){
                console.log(e.status);
                console.log(e.responseText);
            }
        });
    });

```

**2. fetch**

https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch

```js
fetch('http://example.com/movies.json')
  .then(function(response) {
    return response.json();
  })
  .then(function(myJson) {
    console.log(myJson);
  });
```

【注意】fetch只有当网络故障的时候才会进行reject

**3. axios**

对xhr的封装

http://axios-js.com/docs/

```js
const axios = require('axios');

// Make a request for a user with a given ID
axios.get('/user?ID=12345')
  .then(function (response) {
    // handle success
    console.log(response);
  })
  .catch(function (error) {
    // handle error
    console.log(error);
  })
  .then(function () {
    // always executed
  });

// Optionally the request above could also be done as
axios.get('/user', {
    params: {
      ID: 12345
    }
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  })
  .then(function () {
    // always executed
  });  

// Want to use async/await? Add the `async` keyword to your outer function/method.
async function getUser() {
  try {
    const response = await axios.get('/user?ID=12345');
    console.log(response);
  } catch (error) {
    console.error(error);
  }
}
```



# 第13章 JS-Web-API-存储

本章介绍存储的知识点和题目。包括 cookie、localStorage 和 sessionStorage 。本章内容虽然不多，但不可不会。

## 13-1 如何理解 cookie

> 摘自《图解http》
>
> HTTP是无状态协议，她不会之前发生过的请求和相应的状态进行管理，也就是说，无法根据之前的状态进行本次的请求处理。
>
> 引入cookie，**Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。**
>
> * Cookie会根据从浏览器发送的响应报文内`Set-Cookie`的首部字段信息，通知客户端保存Cookie
> * 下次客户端再往服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送出去
> * 服务端发现客户端发送过来的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

**cookie**

* 本身用于浏览器和server通讯
* 被“借用”到本地存储来（h5出现之前一直使用）
* 可用`docuemnt.cookie='...'`来修改

<img src="img/image-20201126170203492.png" alt="image-20201126170203492" style="zoom: 67%;" />

<img src="img/image-20201126170211503.png" alt="image-20201126170211503" style="zoom:67%;" />

![image-20201126170355359](img/image-20201126170355359.png)

<img src="img/image-20201126170429569.png" alt="image-20201126170429569" style="zoom: 67%;" />

**cookie的缺点**

* 存储大小，最大4KB
* http请求时需要发送到服务端，增加请求数据量
* 只能用`document.cookie='...'`来修改，太过简陋

## 13-2 localStorage SessionStorage 和 cookie

**localStorage和sessionSTorage**

* 是HTML5专门为存储而设计的，最大可存5M
* API简单易用，`setItem` `getItem`
* 不会随着http请求被发送出去

<img src="img/image-20201126170825562.png" alt="image-20201126170825562" style="zoom:80%;" />

**localStorage和sessionSTorage的区别**

* `localStorage`数据会永久存储，除非代码或手动删除（补充：localStorage API不支持过期时间，因为`localStorage`一经存储除非手动删除是不会过期的。）
* `sessionStorage`数据只存在于当前会话，浏览器关闭则清空
* 一般用`localStorage`会更多一些

## 13-3 存储面试题

### • 描述localStorage SessionStorage 和 cookie 的区别

> * 容量
>   1. cookie最大4k
>   2. localStorage和sessionStorage最大5M
> * API易用性
>   1. cookie只能用`document.cookie='...'`来修改，太过简陋
>   2. localStorage和SessionStorage使用setItem和getItem来修改
> * 是否跟随http请求发送出去
>   1. cookie跟随请求发出
>   2. localStorage永久存储，sessionStorage只存在于当前会话，都不会随着请求发出


# 第14章 http 面试题

前端工程师做出网页，需要通过网络请求向后端获取数据，因此 http 协议是前端面试的必考内容。本章讲解 http 协议常考的知识点，如状态码、header、method、缓存等。特别是 http 缓存策略，非常重要。

## 14-1 http的几个面试题

**http面试题**

* 前端工程师不只开发界面
* 也需要调用后端的接口，提交/获取数据 —— http协议
* 要求实现掌握好ajax

## 14-2 http状态码

**http状态码**

* 状态码分类
* 常见状态码
* 关于协议和规范

### • http常见的状态码有哪些

**状态码分类**

| 状态码分类 |                |       |
| ---------- | -------------- | ----- |
| 1xx        | 服务器收到请求 |       |
| 2xx        | 请求成功       | 如200 |
| 3xx        | 重定向         | 如302 |
| 4xx        | 客户端错误     | 如404 |
| 5xx        | 服务端错误     | 如500 |

**常见状态码**

| 常见状态码 |              |                                                              |
| ---------- | ------------ | ------------------------------------------------------------ |
| 200        | 成功         |                                                              |
| 301        | 永久重定向   | 配合location，浏览器自动处理（eg 你的网站域名到期了，每次访问旧域名都要重新指向新的域名） |
| 302        | 临时重定向   | 配合location，浏览器自动处理（eg 浏览器访问一个地址，这个地址返回302，浏览器自动访问另一个地址（只是这次）） |
| 304        | 资源未被修改 | （eg 之前请求过资源，服务端资源未改变，可直接使用客户端未过期的缓存） |
| 400        | 错误请求     | 服务器不理解请求的语法                                       |
| 401        | 身份验证错误 | 此页要求授权，您可以不希望将此网页纳入索引                   |
| 404        | 资源未找到   | 服务器上无法找到请求的资源                                   |
| 403        | 没有权限     | 请求资源的访问被服务器拒绝了（eg 从未授权的发送源IP地址试图访问） |
| 404        | 未找到       | 例如：对于服务器上不存在的网页会返回此代码                   |
| 500        | 服务器错误   | 服务器端在执行请求时发生了错误                               |
| 503        | 服务不可用   | 服务器暂出于超负载或正在进行停机维护，现在无法处理请求       |
| 504        | 网关超时     |                                                              |



**关于协议和规范**

* 就是一个约定
* 要求大家都跟着执行
* 不要违反规范，例如IE浏览器

## 14-3 Restful-API

**http methods**

* 先讲传统的methods
* 在讲现在的methods
* 最后讲一下Restful-API

**传统的methods**

* get获取服务器的数据
* post向服务器提交数据
* 简单的网页功能，就这两个操作

**现在的methods**

* get获取数据
* post新建数据
* patch/put更新数据
* delete删除数据

### • 什么是Restful-API

> **Restful API**
>
> * 一种新的API设计方法（早已推广使用）
> * 传统API设计：把每个url当作一个功能
> * Restful API设计：把每个url当作一个唯一的资源

> **如何设计成一个资源？**
>
> * 尽量不用url参数
> * 用method表示操作类型

1. 不使用url参数
   * 例如：传统的API设计：`/api/list?pageIndex=2 `
   * Restful API设计：`/api/list/2`
2. 用method表示操作类型
   * 传统API设计
     * post请求 `/api/create-blog`
     * post请求 `/api/update-blog?id=100`
     * get请求 `/api/get-blog?id=100`
   * Restful API设计
     * post请求 `/api/blog`
     * fetch请求 `/api/blog/100`
     * get请求 `/api/blog/100`

## 14-4 http header

### • http有哪些常见的header

**http headers**

* 常见的Request Headers
* 常见的Response Headers

> **Request Headers**
>
> * `Accept` 浏览器可接受的数据格式
> * `Accept-Encoding` 浏览器可接受的内容编码压缩算法，如gzip
> * `Accept-Language` 浏览器可接受的语言，如 zh-CN 
> * `Connection:keep-alive` 一次TCP连接重复使用（因为HTTP1.1之前的HTTP版本默认连接都是非持久连接，为此，要想在旧版本地HTTP协议上维持持续连接，则需要指定Connection字段的值为keep-alive）
> * `cookie` 服务器接收到的Cookie信息
> * `Host`请求资源所在服务器
> * `User-Agent`（简称UA）浏览器信息
> * `Content-type` 发送数据的格式，如application/json
> * `If-Match` 条件请求，服务器接收到附带条件的请求后，只有判断条件为真，才会执行请求（例如If-Match If-Modified-Since If-None-Match If-Range）
>
> **Response Headers**
>
> * `Content-type` 返回数据的格式，如application/json
> * `Content-length` 返回数据的大小，多少字节
> * `Content-Encoding`返回数据的压缩算法，如gzip
> * `Set-Cookie` 开始状态管理所使用的Cookie信息
> * `ETag` ETag能后告诉客户端实体标识，服务器会为每份资源分配对应的ETag值

以www.baidu.com为例

Request Header

<img src="img/image-20201126214033492.png" alt="image-20201126214033492" style="zoom:67%;" />

<img src="img/image-20201126214210025.png" alt="image-20201126214210025" style="zoom:67%;" />

Response Header

<img src="img/image-20201126214309797.png" alt="image-20201126214309797" style="zoom:67%;" />

**自定义header**

![image-20201126214423341](img/image-20201126214423341.png)

**缓存相关的headers**

* `Cache-Control` Expires
* `Last-Modified` IF-Modified-Since
* `Etag` If-None-Match

## 14-5 http为何需要缓存

**http缓存**

* 关于缓存的介绍
* http缓存策略（强制缓存+协商缓存）
* 刷新操作方式，对缓存的影响

**关于缓存**

* 什么是缓存？

  * 第一次访问完，第二次访问的时候不需要重新获取所有的资源，缓存就是可以将一些资源暂存下来不用重新获取

* 为什么需要缓存？

  * 使得页面加载更快：网络请求很慢，通过缓存可以有有效减少网络请求的数量和体积;
  * 网络请求是不稳定的：缓存可以优化用户请求数据的过程

* 哪些资源可以被缓存？

  * 静态资源(js css img)很容易被缓存（因为上线后不易修改）

  * webpack里根据文件内容生成了哈希值，一旦文件内容改变哈希值会改变，如下：

    <img src="img/image-20201127100913263.png" alt="image-20201127100913263" style="zoom:80%;" />

  * html和业务数据不应被缓存

## 14-6 http强制缓存

### • cache-control是什么意思

> Cache-Control ： 控制缓存的行为

**http缓存 - 强制缓存**

<img src="img/image-20201127101146008.png" alt="image-20201127101146008" style="zoom:67%;" />

* 如果服务端感觉这个资源可以被缓存，它就加一个Cache-Control
* 如果服务端感觉这个资源没法被缓存或者不适合被缓存，就不加

**Cache-Control**

* 服务端控制，是控制强制缓存的逻辑

* Cache-Control在Response Headers中

* 例如:`Cache-Control:max-age=315360 (单位是秒)`

* <img src="img/image-20201127102546281.png" alt="image-20201127102546281" style="zoom:50%;" />

* 如果有cache-control的情况：

  <img src="img/image-20201127102611649.png" alt="image-20201127102611649" style="zoom:50%;" />

  <img src="img/image-20201127103029243.png" alt="image-20201127103029243" style="zoom:50%;" />

* 如果缓存失效的情况下：需要重新请求资源，以使得下一次请求可以直接从本地缓存返回资源

  <img src="img/image-20201127103108476.png" alt="image-20201127103108476" style="zoom:50%;" />

  

  **cache-control的值**

  通过指定headers中Cache-Control的指令，就能操作缓存的工作机制
  
  ```
  Cache-Control:private,max-age=0,no-cache
  ```

  

  * `max-age` 做缓存
  * `no-cache` 不用强制缓存，交给服务端处理（只是不用本地缓存）
  * `no-store` 不用本地缓存，而且不用服务端的一些缓存措施（ 彻底）（不常见)
  * `private`只能允许用户做缓存(仅向特定用户返回响应)
  * `public`允许路由/中间代码做缓存（可向任意方提供响应的缓存）
  
  **关于Expires**
  
  * 同为Response Headers中
  * 同为控制缓存过期
  * 已被Cache-Control代替

## 14-7 http协商缓存(对比缓存)

**http缓存 - 协商缓存**

* 服务器端缓存策略（ 注意：服务端判断这个资源能不能用缓存的内容，而不是资源缓存到服务端）
* 服务端判断客户端资源，是否和服务端资源一样
* 一致返回304，否则返回200和最新的资源

<img src="img/image-20201127104157762.png" alt="image-20201127104157762" style="zoom:50%;" />

**资源标识**

* 在Response Headers中，有两种
* `Last-Modified`资源的最后修改时间
* `Etag`资源的唯一标识（一个字符串，类似人类的指纹）

### • Etag和Last-Modified是什么意思

`Last-Modified`资源的最后修改时间

<img src="img/image-20201127104536716.png" alt="image-20201127104536716" style="zoom:50%;" />

`Etag`资源的唯一标识（根据资源内容来计算的一个字符唯一标识字符串）



<img src="img/image-20201127104924954.png" alt="image-20201127104924954" style="zoom:50%;" />

**例子**

<img src="img/image-20201127105127490.png" alt="image-20201127105127490" style="zoom:50%;" />

<img src="img/image-20201127105147712.png" alt="image-20201127105147712" style="zoom:50%;" />



**Last-Modified和Etag共存**

* 会优先使用Etag
* 因为Lst-Modified只能精确到秒级
* 如果资源被重复生成，而内容不变，则Etag更精确

### • 描述一下http的缓存机制（重要）

<img src="img/image-20201127105658333.png" alt="image-20201127105658333" style="zoom: 80%;" />



## 14-8 刷新页面对http缓存的影响

**三种刷新操作**

* 正常操作：地址栏输入url，跳转链接，前进后退等
* 手动刷新：F5，点击刷新按钮，右击菜单刷新
* 强制刷新：ctrl+f5

**不同刷新操作，不同的缓存策略**

* 正常操作：强制缓存有效，协商缓存有效
* 手动刷新：强制缓存失效，协商缓存有效
* 强制刷新：强制缓存失效，协商缓存失效

> **小结**
>
> * 强制缓存 Cache-Control
> * 协商缓存 Last-Modified和Etag，304状态码
> * 完整的流程图

## 14-9 http考点总结

> **http面试题 - 总结**
>
> * http状态码
> * http method
> * Restful API
> * http headers
> * http缓存策略

## 14.10 自整理补充内容

备注：题目摘自牛客网面经，答案整理自《图解http》

**http与https**

> http：超文本传输协议
>
> * http用于客户端和服务器端之前的通信
> * http是不保存状态的协议
> * 在HTTP协议中有可能存在信息窃听或身份伪装等安全问题，例如
>   * 通信使用明文（不加密），内容可能会被窃听
>   * 不验证通信方的身份，因此有可能遭遇伪装
>   * 无法证明报文的完整性，所以有可能已遭篡改
>
> https：Http Secure
>
> * **HTTP+加密+认证+完整性保护 = HTTPS**
>   * 证书可证明服务器或客户端的身份
> * HTTPS是身披SSL外壳的Http
>   * HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL(Secure Socket Layer)和TLS(Transport Layer Security)协议代替而已
>   * 通常，HTTP直接和TCP通信。当使用SSL，则演变成先和SSL通信，再由SSL和TCP通信了
> * HTTPS采用混合加密机制
>   * Https采用共享密钥加密和公共密钥加密两者并用的混合加密机制
>   * Https协议需要CA证书，费用较高

**TCP协议三次握手**

> * 为了准确无误地将数据送达目标处，TCP协议采用了三次握手策略。
> * 用TCP协议把数据包送出去后，TCP一定会向对方确认是否成功送达。
> * 握手过程中使用了TCP的标志(flag) —— SYN(synchornize)和ACK（acknowledgement）
>
> ![image-20201211220908849](img/image-20201211220908849.png)
>
> 三次握手过程
>
> 1. 发送端发送一个带SYN标志的数据包给对方
> 2. 接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息
> 3. 最后，发送端再回传一个带ACK标志的数据包，代表握手结束

**TCP和UDP的区别**

> 1. TCP是面向连接的，UDP是无连接的即发送数据前不需要先建立链接。
> 2. TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。 并且因为tcp可靠，面向连接，不会丢失数据因此适合大数据量的交换。
> 3. TCP是面向字节流，UDP面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如IP电话和视频会议等）。
> 4. TCP只能是1对1的，UDP支持1对1,1对多。
> 5. TCP的首部较大为20字节，而UDP只有8字节。
> 6. TCP是面向连接的可靠性传输，而UDP是不可靠的。

**WebSocket的实现和应用**

> 1. 什么是WebSocket?
>    * WebSocket，即Web浏览器与Web服务器之间全双工通信标准；是HTML5中的协议，支持持久连续，http协议不支持持久性连接。Http1.0和HTTP1.1都不支持持久性的链接，HTTP1.1中的keep-alive，将多个http请求合并为1个
>    * 一旦确立WebSocket通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文
> 2. WebSocket特点？
>    * 推送功能：支持由服务器向客户端推送数据的推送功能，这样，服务器可直接发送数据，而不必等待客户端的请求
>    * 减少通信量：只要建立起WebSocket，就可以一直保持连接状态
>
> 头部字段多了下面2个属性：
>
> ```
> Upgrade:webSocket
> Connection:Upgrade
> ```
>
> 告诉服务器发送的是websocket
>
> 

# 第15章 开发环境

本章介绍开发环境相关的知识点和题目。包括 git ，调试工具，抓包工具，webpack 和 babel ，以及 linux 常用命令。熟练使用开发环境的各个工具，才能证明你真的做过前端开发，真的有项目经验，否则只能被认定为菜鸟小白。

**关于开发环境**

* 面试官想通过开发环境了解候选人的实际工作情况
* 开发环境的工具，能体现出工作产出的效率
* 会以聊天形式为主，不会问具体的问题

## 15-1 前端开发常用的开发工具 

**开发环境**

* git
* 调试工具
* 抓包
* webpack babel
* linux常用命令

## 15-2 什么是 git

**git**

* 最常用的代码版本管理工具
* 大型项目需要多人协作开发，必须熟用git
* 如果你不知道或者之前不用git，不会通过面试
* Mac OS自带git命令，windows可去官网下载安装
* git服务端常见的有 Github coding.net等
* 大公司会搭建自己的内网git服务

## 15-3 git 的常用命令

**常用git命令**

* `git add .`
* `git diff`
* `git checkout xxx`
* `git commit -m "xxx"`
* `git push origin masyer`
* `git pull origin masyer`
* `git branch`
* `git checkout -b xxx/git checkout xxx`
* `git merge xxx`
* `git stash`（暂存，放到一边）

## 15-5 如何用chrome调试 js代码

**chorme调试工具**

* 一般不会面试时考察
* 但这是前端工程师必备的技能（不算知识）

**chorme**

* Elements
* Console
* debugger
* Network
* Application

## 15-6 移动端 h5 如何抓包网络请求

**抓包**

* 移动端h5页，查看网络请求，需要用工具抓包
* windows一般用fiddler
* Mac OS 一般用charles
* 抓包过程
  1. 手机和电脑连同一个局域网
  2. 将手机代理到电脑上
  3. 手机浏览网页，即可抓包
* 抓包的作用/功能：
  1. 查看网络请求 
  2. 网址代理
  3. 查看https的内容（https是一个加密请求）

**实例演示**

1. 查看网络请求

![image-20201129145738081](img/image-20201129145738081.png)

![image-20201129145832264](img/image-20201129145832264.png)

2. 进行网络代理

   ![image-20201129150023552](img/image-20201129150023552.png)

   ![image-20201129150049690](img/image-20201129150049690.png)

   3. https功能

      ![image-20201129150148954](img/image-20201129150148954.png)

      利用charles来解析这些https请求

      ![image-20201129150306981](img/image-20201129150306981.png)

      ![image-20201129150229337](img/image-20201129150229337.png)

      也可以查看一些引导来学习

      ![image-20201129150344280](img/image-20201129150344280.png)

      

## 15-7 如何配置 webpack

**webpack和babel**

* ES6模块化，浏览器暂不支持
* ES6语法，浏览器并不完全支持
* 压缩代码，整合代码，以让网页加载更快

**实例演示**

1. 初始npm环境 `npm init -y`，创建了package.json文件

   

2. 安装webpack `npm install webpack webpack-cli -D`

   ![image-20201129154105857](img/image-20201129154105857.png)

3. 开始写文件，建一个配置文件 `webpack.copnfig.js`(webpack默认的配置文件的名字)

   ![image-20201129154649146](img/image-20201129154649146.png)

   ![image-20201129154706544](img/image-20201129154706544.png)

4. 执行`npm run build`就可以进行打包

5. 编写一个文件

   ![image-20201129155007382](img/image-20201129155007382.png)

6. 安装插件 `npm install html-webpack-plugin`用来解析html； `npm install webpack-dev-server -D`这个插件用来启动服务

   在webpack.conmfig.js中引进并配置插件

   ```js
   const path = require('path')
   const HtmlWebpackPlugin = require('html-webpack-plugin')
   
   module.exports = {
       // mode 可选 development 或 production ，默认为后者
       // production 会默认压缩代码并进行其他优化（如 tree shaking）
       mode: 'development',
       entry: path.join(__dirname, 'src', 'index'),
       output: {
           filename: 'bundle.js',
           path: path.join(__dirname, 'dist')//当前目录
       },
       module: {
           rules: [
               {
                   test: /\.js$/,
                   loader: ['babel-loader'],
                   include:  path.join(__dirname, 'src'),
                   exclude: /node_modules/
               },
           ]
       },
       plugins: [
           new HtmlWebpackPlugin({
               template: path.join(__dirname, 'src', 'index.html'),
               filename: 'index.html'//访问时的文件名
           })
       ],
       devServer: {
           port: 3000,
           contentBase: path.join(__dirname, 'dist'),  // 根目录
           open: true,  // 自动打开浏览器
       }
   }
   
   ```

   在packjson中加入dev

   ```js
     "scripts": {
       "test": "echo \"Error: no test specified\" && exit 1",
       "build": "webpack --config webpack.prod.js",
       "dev": "webpack-dev-server" //新增加！！
     },
   ```

7. `npm run dev`直接运行，访问`local:3000/index.html`即可

## 15-8 如何配置 babel

如何把ES6的代码变为ES5的代码? 使用babel

1. 安装Babel `npm install @babel/core @babel/preset-env babel-loader-D`三个插件

   安装后

   ![image-20201129155807666](img/image-20201129155807666.png)

2. 在目录里新建`.babelrc`的配置文件，在里面写入

   ```js
   {
       "presets": ["@babel/preset-env"],
       "plugins": []
   }
   ```

   备注：preset-env是babel的很多配置的一个集合，直接用就可以

   

3. 在webpack.config.js里做module的配置

   ```js
   const path = require('path')
   const HtmlWebpackPlugin = require('html-webpack-plugin')
   
   module.exports = {
   	//...
       module: {
           rules: [
               {
                   test: /\.js$/,//以.js结尾的文件
                   loader: ['babel-loader'],//使用babel-loader的插件
                   include:  path.join(__dirname, 'src'),//包含哪些目录
                   exclude: /node_modules/
               },
           ]
       },
       //...
   }
   
   ```

4. 再次运行 npm run dev，查看bundle.js就可以看到ES6的代码都被转换为ES5

## 15-9 ES6 模块化规范是什么

<img src="img/image-20201129161246500.png" alt="image-20201129161246500" style="zoom:80%;" />

<img src="img/image-20201129161228755.png" alt="image-20201129161228755" style="zoom:80%;" />



## 15-10 如何配置 webpack 生产环境

怎么配置生产环境的webpack打包

1. 新建文件 webpack.prod.js(生产环境下的)

   ```js
   const path = require('path')
   const HtmlWebpackPlugin = require('html-webpack-plugin')
   
   module.exports = {
       mode: 'production',//修改1 生产环境
       entry: path.join(__dirname, 'src', 'index'),
       output: {
           filename: 'bundle.[contenthash].js',//修改2 根据代码内容算出一个hash的值
           path: path.join(__dirname, 'dist')
       },
       module: {
           rules: [
               {
                   test: /\.js$/,
                   loader: ['babel-loader'],
                   include:  path.join(__dirname, 'src'),
                   exclude: /node_modules/
               },
           ]
       },
       plugins: [
           new HtmlWebpackPlugin({
               template: path.join(__dirname, 'src', 'index.html'),
               filename: 'index.html'
           })
       ]
   }
   
   ```

   在package.json里改webpack配置的地址

   ```js
   {
     "scripts": {
       "test": "echo \"Error: no test specified\" && exit 1",
       "build": "webpack --config webpack.prod.js",//注意这里改了
       "dev": "webpack-dev-server"
     }
   }
   
   ```

2. 重新 npm run build 出来的代码（注意：文件名里面的乱码就是contenthash的内容，如果代码没有变，文件名就不会变）

   ![image-20201129161719253](img/image-20201129161719253.png)

   可以看到其中的代码已经压缩过

   ![image-20201129161851278](img/image-20201129161851278.png)

## 15-11 前端用到的 linux 常用命令有哪些

**linux命令**

* 公司的线上机器一般都是linux（参考阿里云）
* 测试机也需要保持一致，用linux
* 测试机或者线上机除了问题，本地又不能复现，需要去排查

**常用命令**

* 连接linux机器 `ssh work@192.168.10.21`(用户名@地址)
* 文件
  *  `ls`查看文件  `ls-a`查看隐藏文件 `ll`一列表形式查看
  * `mkdir abc`创建文件夹  `rm -rf abc` 删除文件夹(-r递归删除 -f强制删除)
  * `mv index.html index1.html`修改文件名
  * `mv bundle.745sfsfskw232er.js ../bundle.745sfsfskw232er.j`移动到上级目录
  * `cp a.js a1.js`拷贝复制
  * `rm a1.js`删文件
  * `touch d.js`新建文件
  * `vi d.js` 进入vim再wq
  * `cat d.js` / `head d.js` / `tail d.js`查看文件
  * `grep "bable" package.json`查看文件内容
* vim
  * `vimtutor`系统自带教程

## 15-12 开发环境的考点总结

**开发环境**

* git：常用命令
* 调试工具：chorme的开发者工具
* 抓包 fidder/charles为例
* webpack babel
* linux：常用命令



# 第16章 运行环境

本章介绍运行环境相关的知识点和题目。包括浏览器加载和渲染机制，性能优化，web 安全。网页在浏览器加载和运行，这些内容必须掌握，也是面试常考。

**讲解知识点**

* 网页加载过程
* 性能优化 
* 安全

## 16-1 JS 上线之后在什么哪里运行？

**运行环境**

* 运行环境即浏览器（server端有node.js）
* 下载网页代码，渲染出页面，期间会执行若干js
* 要保证代码在浏览器中：稳定且高效

## 16-2 网页是如何加载并渲染出来的

> **知识点**
>
> * 加载资源的形式
> * 加载资源的过程
> * 渲染页面的过程   

**资源的形式**

* html代码
* 媒体文件，如图片，视频等
* JavaScript css

**加载过程**

* DNS解析：域名 -> IP地址
* 浏览器根据IP地址向服务器发起http请求
* 服务器处理http请求，并返回给浏览器

**渲染过程**

1. 根据HTML代码生成DOM Tree
2. 根据css代码生成CSSOM
3. 将DOM Tree和CSSOM整合形成Render Tree
4. 浏览器根据Render Tree渲染页面
5. 如果遇到`<script>`则暂停渲染，优先加载并执行JS代码，完成再继续
6. 直至把Render Tree渲染完成

## 16-3 网页加载和渲染的示例

<img src="img/image-20201129170157917.png" alt="image-20201129170157917" style="zoom:50%;" />

<img src="img/image-20201129170217164.png" alt="image-20201129170217164" style="zoom:50%;" />

**思考**

为何建议把CSS放在head中？

* 在DOM树加载完之前就得到CSS的规则，DOM树生成后就与所有的CSS整合得到一个Render树，一步渲染完成，不用重复
* 如果网速慢或者浏览器很老，可能会出现DOM树加载中，字体变大变小（DOM生成后才加载css）这样的视觉错乱

<img src="img/image-20201129170714298.png" alt="image-20201129170714298" style="zoom: 67%;" />

**思考**

为何建议把js放在body最后

* 如果没有body最后，可能出现页面渲染一部分卡住了，加载完js后又继续渲染的情况（延长了页面渲染的时间）
* js放在最后，不阻碍页面的渲染，DOM渲染完之后再执行js

<img src="img/image-20201129171159051.png" alt="image-20201129171159051" style="zoom:50%;" />

<img src="img/image-20201129171306592.png" alt="image-20201129171306592" style="zoom:67%;" />



## 16-4 网页加载和渲染相关的面试题

### • 从输入url到渲染出页面的整个过程

> 从输入url到渲染出页面的整个过程
>
> * 下载资源：各个资源类型，下载过程
> * 渲染页面：结合html css js 图片等

### • window.onload和DOMContentLoaded的区别

> * `window.onload` 资源全部加载完才能执行，包括图片
> * `DOMContentLoaded DOM`渲染完成即可，图片可能尚未下载

示例：

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <title>运行环境 演示</title>
    </head>
    <body>
        <p>一段文字 1</p>
        <p>一段文字 2</p>
        <p>一段文字 3</p>
        <img
            id="img1"
            src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1570191150419&di=37b1892665fc74806306ce7f9c3f1971&imgtype=0&src=http%3A%2F%2Fimg.pconline.com.cn%2Fimages%2Fupload%2Fupc%2Ftx%2Fitbbs%2F1411%2F13%2Fc14%2F26229_1415883419758.jpg"
        />

        <script src="./index.js"></script>
    </body>
</html>
```

```js
const img1 = document.getElementById('img1')
img1.onload = function () {
    console.log('img loaded')
}

window.addEventListener('load', function () {
    console.log('window loaded')
})

document.addEventListener('DOMContentLoaded', function () {
    console.log('dom content loaded')
})
```

![image-20201129171745258](img/image-20201129171745258.png)

## 16-5 前端性能优化有哪些方式

**性能优化**

* 是一个综合性问题，没有标准答案，但要求尽量全面
* 某些细节问题可能会单独提问：手写防抖、节流
* 只关注核心点，针对面试

**性能优化原则**

* 多使用内存，缓存或其他方法
* 减少CPU计算量，减少网络加载耗时
* (适用于所有编程的性能优化 —— 空间换时间)

> **从何入手**
>
> * 让加载更快
> * 让渲染更快

**让加载更快**

* 减少资源体积：压缩代码(eg webpack里production模式下的代码压缩；服务端会进行gzip压缩只原来的1/3)
* 减少访问次数：
  * 合并代码(eg 图片合并：雪碧图)
  * SSR服务端渲染（eg 服务端渲染把页面和页面要显示的内容一起返回出来，前端渲染：页面发送ajax加载数据，下载资源，然后渲染到页面上去）
  * 缓存（eg 减少请求资源的次数）
* 使用更快的网络：CDN（eg CDN是根据区域来做服务器的处理，不同地址请求服务器的速度不一样）

**让渲染更快**

* CSS放在head，JS放在body最下面
* 尽早开始执行JS，用DOMContentLoaded触发
* 懒加载（图片懒加载，上滑加载更多）
* 对DOM查询进行缓存
* 频繁DOM操作，合并到一起插入DOM结构
* 节流 throttle 防抖 debounce（渲染更流程，用户体验的一个优化）

## 16-6 前端性能优化的示例

1. 资源合并

   <img src="img/image-20201130092743755.png" alt="image-20201130092743755" style="zoom: 50%;" />

2. 缓存

   <img src="img/image-20201130092853662.png" alt="image-20201130092853662" style="zoom: 50%;" />

   > **缓存：**
   >
   > * 静态资源加hash后缀，根据文件内容计算hash
   > * 文件内容不变，则hash不变，则url不变
   > * url和文件不变，则会自动触发http缓存机制，返回304

3. CDN

   

   <img src="img/image-20201130093346536.png" alt="image-20201130093346536" style="zoom: 50%;" />

   

4. SSR（server side render）

   * 服务端渲染：将网页和数据一起加载，一起渲染
   * 非SSR（前后端分离）：先加载网页，再加载数据，再渲染数据
   * 早先的JSP ASP PHP都属于SSR；现在的vue React SSR

5. 懒加载

   备注：把图片的地址默认放一个预览图，当浏览器判断到图片露出屏幕的时候，再把这个图片的真正的data-realsrc赋值给图片的src

   <img src="img/image-20201130093651739.png" alt="image-20201130093651739" style="zoom:50%;" />

6. 缓存DOM查询

   <img src="img/image-20201130093836466.png" alt="image-20201130093836466" style="zoom:50%;" />

   <img src="img/image-20201130093902985.png" alt="image-20201130093902985" style="zoom:50%;" />

7. 尽早开始js执行

   【备注】使用DOMConentLoaded触发，没必要等到所有资源都加载完毕

   <img src="img/image-20201130094043988.png" alt="image-20201130094043988" style="zoom:80%;" />

## 16-7 手写防抖 debounce

**防抖 debounce**

示例：

* 监听一个输入框，其文字变化后触发change事件
* 直接用keyup事件，则会频繁触发change事件
* 防抖：用户输入结束或暂停时，才会触发change事件

```html
<html lang="en">
    <head>
        <title>debounce 演示</title>
    </head>
    <body>
        <input type="text" id="input1">
        <script src="./debounce.js"></script>
    </body>
</html> 
```

```js
const input1 = document.getElementById('input1')

// let timer = null
// input1.addEventListener('keyup', function () {
//     if (timer) {
//         clearTimeout(timer)
//     }
//     timer = setTimeout(() => {
//         // 模拟触发 change 事件
//         console.log(input1.value)

//         // 清空定时器
//         timer = null
//     }, 500)//间隔半秒
// })

// 防抖（封装后的一个好的版本，最终返回的是一个函数）
function debounce(fn, delay = 500) {
    // timer 是闭包中的
    let timer = null

    return function () {
        if (timer) {
            clearTimeout(timer)
        }
        timer = setTimeout(() => {
            fn.apply(this, arguments)
            timer = null
        }, delay)
    }
}

//怎么用
input1.addEventListener('keyup', debounce(function (e) {
    console.log(e.target)
    console.log(input1.value)
}, 600))

```

## 16-8 手写节流 throttle

**节流 throttle**

示例：

* 拖拽一个元素时，要随时拿到该元素被拖拽的位置
* 直接用drag事件，则会频繁触发，很容易导致卡顿
* 节流：无论拖拽速度多快，都会每隔100ms触发一次

![image-20201130101135443](img/image-20201130101135443.png)

```html
<html lang="en">
    <head>
        <title>throttle 演示</title>
        <style>
            #div1 {
                border: 1px solid #ccc;
                width: 200px;
                height: 100px;
            }
        </style>
    </head>
    <body>
        <div id="div1" draggable="true">可拖拽<div>
        <script src="./throttle.js"></script>
    </body>
</html>
```

```js
const div1 = document.getElementById('div1')

// let timer = null
// div1.addEventListener('drag', function (e) {
//     if (timer) {
//         return
//     }
//     timer = setTimeout(() => {
//         console.log(e.offsetX, e.offsetY)
//         // 进行操作
//         timer = null
//     }, 100)
// })

// 节流函数工具化
function throttle(fn, delay = 100) {
    let timer = null

    return function () {
        if (timer) {
            return
        }
        timer = setTimeout(() => {
            fn.apply(this, arguments)
            timer = null
        }, delay)
    }
}

div1.addEventListener('drag', throttle(function (e) {
    console.log(e.offsetX, e.offsetY)
},200))
```

## 16-9 如何预防 xss 攻击

**安全**

* 问题：常见的web前端攻击方式有哪些？
* xss（跨站脚本攻击 Cross-Site Scripting）
* CSRF(跨站请求伪造 Cross-Site Request Forgeries)

**XSS攻击**

> 是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或Javascript进行的一种攻击
>
> 可能造成的影响：
>
> * 利用虚假输入表单骗取用户个人信息
> * 利用脚本窃取用户的Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求
> * 显示伪造的文章或图片
> * 【补充】cookie中设置了httponly后js脚本将无法获取cookie信息，这样可以防范xss攻击

* 一个博客网站，我发表一篇博客，其中嵌入`<scritp>`脚本
* 脚本内容：获取cookie，发送到我的服务器（服务器需要配合跨域）
* 发布这篇博客，有人查看它，我轻松收割访问者的cookie

示例：

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <title>xss 演示</title>
    </head>
    <body>
        <p>一个很精彩的博客</p>
        <p>博客文字</p>
        <p>博客文字哈哈哈哈</p>
        <script>console.log("您的cookie：",document.cookie,"已经被这篇博客的嵌入script脚本获取了")</script>
    </body>
</html>
```

![image-20201130103509515](img/image-20201130103509515.png)

当用户在登录状态下访问这篇博客，该博客网站就获得了该用户的cookie，然后发送到该博客的服务器（cookie其中包含用户信息，被别人有意利用非常不安全）

> **如何预防XSS攻击**
>
> * 替换特殊字符，如`<`变成`&lt;`   ` >`变成`&gt；`
> * `<script>`变成`&lt;script&gt;` 直接显示，而不会作为脚本执行
> * 前端要替换，后端也要替换，都做总不会有错

例如：

```js
    <body>
        <p>一个很精彩的博客</p>
        <p>博客文字</p>
        <p>博客文字哈哈哈哈</p>
        &lt;script&gt;alert(document.cookie);&lt;/script&gt;
    </body>
```

![image-20201130104010972](img/image-20201130104010972.png)

【注意】可以使用npm的xss工具来预防

## 16-10 如何预防 xsrf 攻击

**XSRF攻击 **

> 是指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击
>
> 可能有以下影响：
>
> * 利用已通过认证的用户权限更新设定信息等
> * 利用已通过认证的用户权限购买商品
> * 利用已通过认证的用户权限在留言板上发表

* 你正在购物，看中了某个商品，商品id是100
* 付费接口是`xxx.com/pay?id=100`,但没有任何验证
* 我是攻击者，我看中了一个商品，id是200，我现在想让你去买
* 我向你发送一封电子邮件，邮件标题很吸引人
* 但邮件正文隐藏着`<img src=xxx.com/pay?id=200 />` 
* 你一查看邮件，就帮我购买了id是200的商品

【备注】：你已登录该购物网站，访问邮件的时候用户信息（即cookie）已经带上了，因为img的请求可以跨域，所以你就在该网站购买了id是200的商品

> **XSRF预防**
>
> * 使用post接口（post接口下的跨域需要服务端支持）
> * 增加验证，例如密码，短信验证码，指纹等（现在的购物网站多是这种方式）

## 16-11 运行环境的考点总结

**运行环境**

* 网页加载过程
  * 加载资源的形式
  * 加载资源的过程
  * 渲染页面的过程
* 性能优化 
  * 让加载更快
  * 让渲染更快
* 安全
  * XSS跨站请求攻击和预防
  * XSRF跨站请求伪造和预防

# 第17章 课程总结

本章回顾所有题目和知识点，总结课程内容。还会介绍一些实用的面试技巧，避免你在面试中犯一些低级错误。

## 17-1 课程总结

* 知识点 -> 题目
* 回顾知识点，思维导图【前端基础面试课-思维导图.png】
* 回顾之前的所有问题

## 17-2 面试技巧 

* 关于简历
  * 简洁明了，突出个人技能和项目经验
  * 可以把个人博客，开源作品放在简历中（但博客要有内容）
  * 不要造假，保证能力上的真实性（斟酌用词，如精通xxx）
* 面试过程中注意事项
  * 如何看待加班：像借钱，救急不救穷
  * 千万不要挑战面试官，反考面试官
  * 学会给面试官惊喜，证明你能想到更多，做的更好，但不要太多
  * 遇到不会的问题，说出你知道的部分即可，但别岔开话题
  * 谈谈你的缺点：说一下你最近在学什么即可

# 第18章 真题模拟

本章节，通过一部分高频面试真题，带大家分析面试，以及如何解答。

**面试真题**

* 都是网上的高频JS初级面试题
* 验证和复习之前学过的知识
* 补充其他技能，如正则表达式，数组API

**讲解前提示**

* 题目没有按照知识点或者难度排序，即混排
* 只筛选了初级面试题，即本课程知识体系之内的

## 1 var 和let const的区别\

> * var是ES5语法，let const是ES6语法；var有变量提升
> * var和let是变量，可修改；const是常量，不可修改；
> * let const有块级作用域，var没有
>
> 补充：
>
> * 使用const声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。
>
>   ```js
>   const a; //  SyntaxError: Missing initializer in const 
>   ```
>
> * let的一个特性是禁止在同一个作用域下重复声明

## 2 何为变量提升？

> var 有变量提升

```js
// 变量提升 ES5
console.log(a) // undefined
var a = 200

//上面两行等于下面三行
// var a
// console.log(a) // undefined
//a = 200
```

## 3 typeof返回哪些类型

> * undefined string number boolean symbol （值类型）
> * object（注意：typeof null === 'object'）（引用类型）
> * function

## 4 列举强制类型转换和隐式类型转换

> * 强制：`parseInt` `parseFloat` `toString`等
> * 隐式：`if`、逻辑运算、==、+拼接字符串

## 5 手写深度比较，模拟lodash.isEqual

<img src="img/image-20201130151329449.png" alt="image-20201130151329449" style="zoom:50%;" />

```js
//判断是否是对象或数组
function isObject(obj){
  return typeof obj === 'object' && obj!==null
}

function isEqual(obj1, obj2) {
  if(!isObject(obj1) || ! isObject(obj2)){
    //值类型（注意，参与equal的一般不会是函数）
    return obj1 === obj2;
  }
  if(obj1 === obj2){
    return true;//isEqual(obj1,obj1)的情况
  }
  //两个都是对象或数组，而且不相等
  //1.先取出obj1和obj2的keys，比较个数
  const obj1Keys = Object.keys(obj1);
  const obj2Keys = Object.keys(obj2);
  if(obj1Keys.length !== obj2Keys.length){
    return false;
  }
  //2.以obj1为基准，和obj2依次递归比较
  for(let key in obj1){
    //比较当前key的val -- 递归！
    const res = isEqual(obj1[key],obj2[key])
    if(!res){
      return false;
    }
  }
  //3. 全相等
  return true;
}

//测试
const obj1 = {
	a: 100,
	b: {
		x: 100,
		y: 200,
	},
};
const obj2 = {
	a: 100,
	b: {
		x: 100,
		y: 200,
  },
};
console.log(isEqual(obj1, obj2));
```

注意：

* 思路类似深拷贝

* 对数组使用Object.keys得到的是数组的索引；对对象使用则得到keys

  ![image-20201130153816049](img/image-20201130153816049.png)

  

## 6 split()和join()的区别

```"
'1-2-3'.split('-') //[1,2,3]
[1,2,3].join('-')//"123
```

## 7 数组的pop push unshift shift分别做什么

* 功能是什么？
* 返回值是什么？
* 是否回对原数组造成影响？

**返回元素或length 改变源数组**

```js
const arr = [10, 20, 30, 40]

// pop
const popRes = arr.pop()
console.log(popRes, arr)//40 [ 10, 20, 30 ]

// shift
const shiftRes = arr.shift()
console.log(shiftRes, arr)//10 [ 20, 30 ]

// push
const pushRes = arr.push(50) // 返回 length
console.log(pushRes, arr)//3 [ 20, 30, 50 ]

// unshift
const unshiftRes = arr.unshift(5) // 返回 length
console.log(unshiftRes, arr) //4 [ 5, 20, 30, 50 ]
```

**纯函数：不改变源数组，返回一个新的数组**

```js
// 纯函数：1. 不改变源数组（没有副作用）；2. 返回一个数组
const arr = [10, 20, 30, 40]

// concat
const arr1 = arr.concat([50, 60, 70])
// map
const arr2 = arr.map(num => num * 10)
// filter
const arr3 = arr.filter(num => num > 25)
// slice
const arr4 = arr.slice()
```

**非纯函数**

```js
// 非纯函数
// push pop shift unshift
// forEach
// some every
// reduce
```

## 8 数组slice和splice的区别

* 功能区别（slice-切片，splice-剪接）
* 参数和返回值
* 是否纯函数

```js
// slice 纯函数
const arr = [10, 20, 30, 40,50]
const arr1 = arr.slice()
const arr2 = arr.slice(1, 4)//[20,30,40]不包含结束索引
const arr3 = arr.slice(2)//从2开始直到最后
const arr4 = arr.slice(-3)//倒数前三个
```

```js
// splice 非纯函数
const arr = [10, 20, 30, 40,50]
const spliceRes = arr.splice(1, 2, 'a', 'b', 'c')
console.log(spliceRes, arr) //[ 20, 30 ] [ 10, 'a', 'b', 'c', 40, 50 ]
```

## 9 [10,20,30].map(parseInt)返回结果是什么？

* map的参数和返回值
* parseInt参数和返回值

```js
const res = [10, 20, 30].map(parseInt)
console.log(res)//[ 10, NaN, NaN ]
```

拆开来看

```js
// 拆解
[10, 20, 30].map((num, index) => {
    return parseInt(num, index)
})
```

![image-20201130161055098](img/image-20201130161055098.png)

## 10 ajax请求get和post的区别

> * get一般用于查询操作，post一般用于用户提交操作
> * get参数拼接在url上，post放在请求体内（数据体积可更大）
> * 安全性：post易于预防CSRF

## 11 函数call和apply的区别

```js
fn.call(this,p1,p2,p3);
fn.apply(this,arguments)
```

## 12 事件代理(委托）是什么？

<img src="img/image-20201130161614409.png" alt="image-20201130161614409" style="zoom:67%;" />



## 13 闭包是什么，有什么特性？有什么负面影响？

* 回顾作用域和自由变量
* 回顾闭包应用场景：函数作为参数被传入，函数作为返回值被返回
* 回顾：自由变量的查找，要在函数定义的地方（而非执行的地方）
* **影响：变量会常驻内存，得不到释放**。所以闭包不要乱用。

代码示例：

```js
// // 自由变量示例 —— 内存会被释放
// let a = 0
// function fn1() {
//     let a1 = 100

//     function fn2() {
//         let a2 = 200

//         function fn3() {
//             let a3 = 300
//             return a + a1 + a2 + a3
//         }
//         fn3()
//     }
//     fn2()
// }
// fn1()

// // 闭包 函数作为返回值 —— 内存不会被释放
// function create() {
//     let a = 100
//     return function () {
//         console.log(a)
//     }
// }
// let fn = create()
// let a = 200
// fn() // 100

function print(fn) {
    let a = 200
    fn()
}
let a = 100
function fn() {
    console.log(a)
}
print(fn) // 100
```

## 14 如何阻止事件冒泡和默认行为？

* `event.stopPropagation()`
* `event.preventDefault()`

## 15 查找，添加，删除，移动DOM节点的方法？

* 看之前的内容 

## 16 如何减少DOM操作？

* 缓存DOM查询结果
* 多次DOM操作，合并到一次插入

## 17 解释jsonp的原理，为何它不是真正的ajax？

> * 浏览器的同源策略（服务端没有同源策略）和跨域
>
> * 哪些html标签能绕过跨域？ `<img> <script><iframe>`这些标签不受同源限制
>
> * jsonp的核心原理是**目标页面回调本地页面的方法，并带入参数**
>
>   <img src="img/image-20201130193633521.png" alt="image-20201130193633521" style="zoom:67%;" />
>
>   用通过跨域，必须经过服务器端的允许
>   
> * JSONP的异常判断一般是onerror事件和超时timer来判断

## 18 docuemnt load 和 ready的区别

<img src="img/image-20201130193747937.png" alt="image-20201130193747937" style="zoom:67%;" />

## 19 == 和 === 的不同

> * == 会尝试类型转换
> * === 严格相等

## 20 函数声明和函数表达式的区别

> * 函数声明`function fn(){...}`
> * 函数表达式 `const fn = function(){...}`
> * **函数声明会在代码执行前预加载，而函数表达式不会**

```js
// 函数声明
const res = sum(10, 20)
console.log(res)
function sum(x, y) {
    return x + y
}
```

```js
// 函数表达式
var sum = function (x, y) {
    return x + y
}
var res = sum(10, 20)
console.log(res)
```

## 21 new Object()和Object.create()的区别

* `{}`等同于`new Object()`,原型是Object.prototype
* `Object.create(null)`没有原型
* `Object.create({...})`可指定原型
* `Object.create()`创建了一个空对象，其原型指向了传入的对象

```js
const obj1 = {
    a: 10,
    b: 20,
    sum() {
        return this.a + this.b
    }
}

const obj2 = new Object({
    a: 10,
    b: 20,
    sum() {
        return this.a + this.b
    }
})

const obj21 = new Object(obj1) // obj1 === obj2 两个对象一样

const obj3 = Object.create(null)
const obj4 = new Object() // {}

const obj5 = Object.create({
    a: 10,
    b: 20,
    sum() {
        return this.a + this.b
    }
})

const obj6 = Object.create(obj1)
```

## 22 关于this的场景题

<img src="img/image-20201130195314994.png" alt="image-20201130195314994" style="zoom:50%;" />

打印：

```js
1
undefined
```

## 23 关于作用域和自由变量的场景题

**题目1**

```js
let i;
for(i=1;i<=3;i++){
  setTimeout(function(){
    console.log(i);
  },0)
}
//打印4 4 4 
```

```js
for(let i=1;i<=3;i++){
  setTimeout(function(){
    console.log(i);
  },0)
}
//打印1 2 3
```

**题目2**

```js
let a = 100

function test(){
  console.log(a);
  a = 10;
  console.log(a);
}

test();
console.log(a);
//打印 100 10 10
```



## 24 判断字符串以字母开头，后面字母数字下划线，长度6-30

> `const reg = /^[a-zA-Z]\w{5,29}$/`

推荐文档

https://deerchao.cn/tutorials/regex/regex.html

手写常见正则表达式

`^`是正则表达式匹配**字符串开始**位置

`$`是正则表达式匹配**字符串结束**位置

```js
// 邮政编码
/\d{6}/

// 小写英文字母
/^[a-z]+$/

// 英文字母
/^[a-zA-Z]+$/

// 日期格式 2019.12.1
/^\d{4}-\d{1,2}-\d{1,2}$/

// 用户名
/^[a-zA-Z]\w{5, 17}$/

// 简单的 IP 地址匹配
/\d+\.\d+\.\d+\.\d+/

//英文单词
/[^\s]+/g
```

## 25 手写字符串trim方法，保证浏览器兼容性

```js
//去除字符串前面和后面的空白
String.prototype.trim = function(){
	return this.replace(/^\s+/,'').replace(/\s+$,'')
}
//（原型，this，正则表达式
```

## 26 如何获取多个数字中的最大值

```js
Math.max(10,20,40,80)
//以及Max.min
```

```js
function max(){
  const nums = Array.prototype.slice.call(arguments)//变为数组
  let max = 0;
  nums.forEach(n=>{
    if(n>max){
      max = n
    }
  })
  return max
}
```

## 27 如何用JS实现继承

* class继承（推荐）
* prototype继承

## 28 如何捕获js程序中的异常

<img src="img/image-20201130204432131.png" alt="image-20201130204432131" style="zoom: 67%;" />

## 29 什么是JSON？

> * json是一种数据格式，本质是一段字符串
> * json格式和js对象结构一致，对JS语言更友好
> * `window.JSON`是一个全局对象 
> * `JSON.stringify` 对象转换成json字符串
> * `JSON.parse`字符串转换成对象

<img src="img/image-20201130204922930.png" alt="image-20201130204922930" style="zoom: 67%;" />

## 30 获取当前页面url参数

![image-20201130205149605](img/image-20201130205149605.png)

* 传统方式，查找`location.search`

  ```js
  // 传统方式
  function query(name) {
      const search = location.search.substr(1) // 类似 array.slice(1)
      // search: 'a=10&b=20&c=30'
      const reg = new RegExp(`(^|&)${name}=([^&]*)(&|$)`, 'i')
      const res = search.match(reg)
      if (res === null) {
          return null
      }
      return res[2]
  }
  console.log( query('a') )//10
  ```

  res匹配到的结果

  ![image-20201130205953387](img/image-20201130205953387.png)

* 新API `URLSearchParams`

  ```js
  // URLSearchParams
  function query(name) {
      const search = location.search
      const p = new URLSearchParams(search)
      return p.get(name)
  }
  console.log( query('b') )//20
  ```



**补充一个编程题：获取url参数**

获取 url 中的参数

1. 指定参数名称，返回该参数的值 或者 空字符串
2. 不指定参数名称，返回全部的参数对象 或者 {}
3. 如果存在多个同名参数，则返回数组

输入

```
http://www.nowcoder.com?key=1&key=2&key=3&test=4#hehe key
```

输出

```
[1, 2, 3]
```

答案1 使用正则

```js
function getUrlParam(sUrl,sKey){
	var result = {};
	sUrl.replace(/\??(\w+)=(\w+)&?/g,function(a,k,v){
		if(result[k] !== void 0){
			var t = result[k];
			result[k] = [].concat(t,v);
		}else{
			result[k] = v;
		}
	});
	if(sKey === void 0){
		return result;
	}else{
		return result[sKey] || '';
	}
}

var res = getUrlParam("http://www.nowcoder.com?key=1&key=2&key=3&test=4#hehe","key");
console.log(res);
```

1. replace()的第一个参数是一个正则表达式，第二个参数是一个回调函数，每匹配到一个符合正则表达式的结果就回调一次。参数a代表该次匹配到的字符串，k代表该次匹配到的字符串中符合第一个分组的部分，v代表该次匹配到的字符串中符合第二个分组的部分
2. 当concat()的参数是具体的值时，意味着将参数连接到调用concat()方法的数组上。result原本是一个空的对象，当回调函数第一次执行时，向该对象添加了一个key-value对，但此时的value是一个字符串"1"。因此，在回调函数第二次执行时，要向一个空数组添加字符串"1"和"2"，这也是为什么要用[].concat(k,v)。
3. 正则表达式的开头的\?是不能省略的，否则.com?key=1匹配不到。

## 31 将url参数解析为JS对象

<img src="img/image-20201130210252666.png" alt="image-20201130210252666" style="zoom:67%;" />

<img src="img/image-20201130210354042.png" alt="image-20201130210354042" style="zoom:67%;" />

## 32 手写数组flatern，考虑多层级

<img src="img/image-20201130210408220.png" alt="image-20201130210408220" style="zoom:50%;" />

```js
function flat(arr) {
    // 验证 arr 中，还有没有深层数组 [1, 2, [3, 4]]
    const isDeep = arr.some(item => item instanceof Array)
    if (!isDeep) {
        return arr // 已经是 flatern [1, 2, 3, 4]
    }

    const res = Array.prototype.concat.apply([], arr)
    return flat(res) // 递归
}

const res = flat( [1, 2, [3, 4, [10, 20, [100, 200]]], 5] )
console.log(res)

```

![image-20201130214421085](img/image-20201130214421085.png) 

## 33 数组去重

* 传统方式，遍历元素挨个比较、去重

  ```js
  // 传统方式
  function unique(arr) {
      const res = []
      arr.forEach(item => {
          if (res.indexOf(item) < 0) {
              res.push(item)
          }
      })
      return res
  }
  ```

* 使用set

  ```js
  // 使用 Set （无序，不能重复）
  function unique(arr) {
      const set = new Set(arr)
      return [...set]
  }
  ```

* 考虑计算效率，尽量使用set的方式

## 34 手写深拷贝

```js
/**
 * 深拷贝
 * @param {Object} obj 要拷贝的对象
 */
function deepClone(obj = {}) {
	if (typeof obj !== "object" || obj == null) {
		// obj 是 null ，或者不是对象和数组，直接返回
		return obj;
	}
	// 初始化返回结果
	let result;
	if (obj instanceof Array) {
		result = [];
	} else {
		result = {};
	}
	for (let key in obj) {
		// 保证 key 不是原型的属性
		if (obj.hasOwnProperty(key)) {
			// 递归调用！！！
			result[key] = deepClone(obj[key]);
		}
	}
	// 返回结果
	return result;
}
```

【注意】`Object.assign(obj1,obj2)`可以实现对象的**浅拷贝**，用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。

## 35 介绍一下 RAF（requestAnimationFrame）

> * 要想动画流畅，更新频率要60帧/s，即16.67ms更新一次视图
> * setTimeout要手动控制频率，而RAF浏览器会自动控制
> * 后台标签或隐藏iframe中，RAF会暂停，而setTimeout依然执行

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <title>JS 真题演示</title>

        <style>
            #div1 {
                width: 100px;
                height: 50px;
                background-color: red;
            }
        </style>
    </head>
    <body>
        <p>JS 真题演示</p>
        <div id="div1"></div>
        <script src="https://cdn.bootcss.com/jquery/3.4.0/jquery.js"></script>
        <script src="./RAF.js"></script>
    </body>
</html>
```

```js
// 3s 把宽度从 100px 变为 640px ，即增加 540px
// 60帧/s ，3s 180 帧 ，每次变化 3px

const $div1 = $('#div1')
let curWidth = 100
const maxWidth = 640

// // setTimeout
// function animate() {
//     curWidth = curWidth + 3
//     $div1.css('width', curWidth)
//     if (curWidth < maxWidth) {
//         setTimeout(animate, 16.7) // 自己控制时间
//     }
// }
// animate()

// RAF
function animate() {
    curWidth = curWidth + 3
    $div1.css('width', curWidth)
    if (curWidth < maxWidth) {
        window.requestAnimationFrame(animate) // 时间不用自己控制
    }
}
animate()

```

![image-20201130215658091](img/image-20201130215658091.png)

## 36 前端性能如何优化?一般从哪几个方面考虑？5

* 原则：多使用内存、缓存，减少计算、减少网络请求 
* 方向：加载页面，页面渲染，页面操作流畅度